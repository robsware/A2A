{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Agent2Agent (A2A) Protocol","text":""},{"location":"#unlock-collaborative-agent-scenarios","title":"Unlock Collaborative Agent Scenarios","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to enable seamless communication and collaboration between AI agents. In a world where agents are built using diverse frameworks and by different vendors, A2A provides a common language, breaking down silos and fostering interoperability.</p> <ul> <li>Blog Post: Announcing the Agent2Agent Protocol (A2A)</li> <li>Watch the A2A Demo Video</li> </ul> <p></p>"},{"location":"#why-a2a-matters","title":"Why A2A Matters","text":"<ul> <li> <p> Interoperability</p> <p>Connect agents built on different platforms (LangGraph, CrewAI, Semantic Kernel, custom solutions) to create powerful, composite AI systems.</p> </li> <li> <p> Complex Workflows</p> <p>Enable agents to delegate sub-tasks, exchange information, and coordinate actions to solve complex problems that a single agent cannot.</p> </li> <li> <p> Secure &amp; Opaque</p> <p>Agents interact without needing to share internal memory, tools, or proprietary logic, ensuring security and preserving intellectual property.</p> </li> </ul>"},{"location":"#a2a-and-mcp-complementary-protocols","title":"A2A and MCP: Complementary Protocols","text":"<p>A2A and the Model Context Protocol (MCP) are complementary standards for building robust agentic applications:</p> <ul> <li>MCP (Model Context Protocol): Connects agents to tools, APIs, and resources with structured inputs/outputs. Think of it as the way agents access their capabilities.</li> <li>A2A (Agent2Agent Protocol): Facilitates dynamic, multimodal communication between different agents as peers. It's how agents collaborate, delegate, and manage shared tasks.</li> </ul> <p>Learn more about A2A and MCP</p>"},{"location":"#get-started-with-a2a","title":"Get Started with A2A","text":"<ul> <li> <p> Read the Introduction</p> <p>Understand the core ideas behind A2A.</p> <p> What is A2A?</p> <p> Key Concepts</p> </li> <li> <p> Dive into the Specification</p> <p>Explore the detailed technical definition of the A2A protocol.</p> <p> Protocol Specification</p> </li> <li> <p> Follow the Tutorials</p> <p>Build your first A2A-compliant agent with our step-by-step Python quickstart.</p> <p> Python Tutorial</p> </li> <li> <p> Explore Code Samples</p> <p>See A2A in action with sample clients, servers, and agent framework integrations.</p> <p> GitHub Samples</p> </li> </ul>"},{"location":"community/","title":"Welcome to the A2A Community","text":"<p>The Agent2Agent (A2A) protocol is generating significant buzz across the tech world, and for good reason! This open interoperability protocol is designed to enable seamless collaboration between AI agents across diverse frameworks and vendors. By standardizing communication, A2A aims to unlock complex workflows, enhance productivity, and foster a new era of \"Agent Interoperability\". Don't just take our word for it \u2013 see what the community is saying!</p>"},{"location":"community/#the-word-on-the-street-social-highlights","title":"The Word on the Street: Social Highlights","text":"<p>The launch of A2A has sparked lively discussions and positive reactions on various social platforms. Here's a glimpse of the excitement:</p> <ul> <li> <p>Rapid Interest and Adoption: The A2A GitHub repository has seen an explosive surge in popularity. This rapid interest underscores the industry's eagerness for a standardized agent communication protocol, with many companies collaborating and contributing.</p> </li> <li> <p>Microsoft's interest via Semantic Kernel: Asha Sharma, Head of AI Platform Product at Microsoft, announced on LinkedIn that \"Semantic Kernel now speaks A2A: a lightweight JSON-RPC protocol that lets agents swap context, not code or credentials, over plain HTTP. Drop it into your Foundry stack for instant, secure, async interoperability with any A2A-compliant agent, regardless of modality\". The post received numerous positive reactions, including \"A2A support in Semantic Kernel is a key unlock \u2014 context-level interoperability without sharing code or creds is how agent ecosystems scale securely across clouds\".</p> </li> <li> <p>Matt Pocock's Diagramming Intent: Matt Pocock, a well-known developer educator, shared on X, \"I've just been reading the Agent2Agent technical docs - Google's new protocol for agent to agent communication. You know what that means. Let's diagram them:\". This tweet, liked and reposted hundreds of times, includes some great diagrams explaining the A2A protocol.</p> </li> <li> <p>Craig McLuckie's \"Hot Take\": Craig McLuckie shared his initial thoughts on LinkedIn, calling it a \"Hot take on Agent2Agent vs MCP\". His post highlighted Google's careful positioning of A2A as focused on interactions between agentic systems, rather than agents interacting with resources (the focus of MCP). This distinction is crucial for improving models' ability to understand expectations from other agents. McLuckie also pointed out the potential for A2A to enable systems to advertise specific capabilities and specialities, which is seen as \"sensible\".</p> </li> </ul>"},{"location":"community/#community-deep-dive-videos","title":"Community deep dive videos","text":"<ul> <li>Zachary Huang explains in his YouTube video, A2A \"complements\" MCP. While MCP acts as a \"USB-C port for AI applications\" connecting agents to tools, A2A acts as a communication standard between the intelligent agents themselves. This layered approach allows for building powerful systems where agents use A2A to coordinate and MCP to access necessary tools.</li> <li>Jack Herrington on his YouTube video walks through some of the provided examples and closes with his opinion that \"Having a specific protocol for agents to talk to other agents is valuable\" and reiterates, \"LLM plus tools are agents. MCP gives agents those tools. So that's why A2A and MCP play really nicely together\".</li> <li>Cole Medin suggested on his YouTube video that \"A2A was released very recently but it's already looking like it's going to follow a similar path\" to MCP in terms of growing interest. He also demonstrates the samples step by step and provides a summary of core concepts.</li> <li>Sam Witteveen covered A2A on his YouTube video immediately after Google Cloud Next and discusses the value of making protocols open and not ending up with conflicting protocols.</li> </ul>"},{"location":"community/#community-contributions-to-a2a","title":"Community Contributions to A2A","text":"<ul> <li>LlamaIndex submitted a sample implementation PR#179</li> <li>Autogen sample server PR#232</li> <li>AG2 + MCP example PR#230</li> <li>PydanticAI example PR#127</li> <li>Go example PR#52</li> <li>Daytona sandbox running agent PR#170</li> </ul>"},{"location":"community/#what-is-driving-this-excitement","title":"What is Driving This Excitement?","text":"<p>The enthusiasm surrounding A2A stems from its potential to address key challenges in building sophisticated AI applications:</p> <ul> <li> <p>Breaking Down Silos: A2A aims to overcome the limitations of siloed AI systems by providing a universal framework for agents built on different platforms to communicate and collaborate securely.</p> </li> <li> <p>Enabling Complex Collaboration: For tasks that require the expertise of multiple specialized agents, A2A provides a standardized way for them to delegate tasks, exchange information, and coordinate actions. This mirrors how human teams work together, distributing responsibilities for greater efficiency.</p> </li> <li> <p>Dynamic Agent Discovery: A key feature of A2A is the ability for agents to discover the capabilities of other agents through standardized \"Agent Cards\". This dynamic discovery allows for more flexible and adaptable multi-agent systems.</p> </li> <li> <p>Complementary to MCP: As stated on our A2A \u2764\ufe0f MCP topic page and affirmed by many community, A2A \"complements\" MCP. MCP acts as a communication standard between models and resources, providing tools for agents. A2A acts as a communication standard between the intelligent agents themselves. This layered approach allows for building powerful systems where agents use A2A to coordinate and MCP to access necessary tools.</p> </li> <li> <p>Open and Community-Driven: Google has released A2A as open source, inviting contributions from the broader community to refine and expand its functionality. This commitment to open collaboration fosters innovation and broad adoption.</p> </li> </ul>"},{"location":"community/#the-future-is-interoperable","title":"The Future is Interoperable","text":"<p>The social media buzz surrounding Google's A2A protocol clearly indicates a strong interest and belief in its potential to revolutionize the development of multi-agent AI systems. By providing a standardized way for AI agents to communicate and collaborate, A2A is poised to unlock new levels of automation, efficiency, and innovation. As enterprises increasingly adopt AI agents for a wide range of tasks, A2A represents a crucial step towards realizing the full power of interconnected AI ecosystems.</p> <p>Stay tuned for more updates and join the growing community building the future of AI interoperability with A2A!</p>"},{"location":"partners/","title":"Partners","text":"<p>Below is a list of partners (and a link to their A2A announcement or blog post, if available) who are part of the A2A community and are helping build, codify, and adopt A2A as the standard standard protocol for AI agents to communicate and collaborate effectively with each other and with users.</p> <p>Note</p> <p>If you're interested in becoming a partner of A2A and getting your listing added to or updated on this page, let us know by submitting this form, and we'll contact you soon!</p> <ul> <li>Accenture</li> <li>Arize</li> <li>Articul8</li> <li>ask-ai.com</li> <li>Atlassian</li> <li>BCG</li> <li>Box</li> <li>C3 AI</li> <li>Capgemini</li> <li>Chronosphere</li> <li>Cognizant</li> <li>Cohere</li> <li>Collibra</li> <li>Contextual</li> <li>Cotality (fka Corelogic)</li> <li>Datadog</li> <li>DataRobot</li> <li>DataStax</li> <li>Decagon.ai</li> <li>Deloitte</li> <li>Devnagri</li> <li>Distyl.ai</li> <li>Elastic</li> <li>Ema.co</li> <li>EPAM</li> <li>Glean</li> <li>GrowthLoop</li> <li>Harness</li> <li>HCLTech</li> <li>Incorta</li> <li>InfoSys</li> <li>Intuit</li> <li>JetBrains</li> <li>JFrog</li> <li>KPMG</li> <li>LabelBox</li> <li>LangChain</li> <li>Livex.ai</li> <li>LlamaIndex</li> <li>LTIMindTtree</li> <li>Lyzr.ai</li> <li>Microsoft</li> <li>McKinsey</li> <li>MongoDB</li> <li>Neo4j</li> <li>New Relic</li> <li>Oracle / NetSuite</li> <li>Pendo</li> <li>PWC</li> <li>Quantiphi</li> <li>S\\&amp;P</li> <li>Salesforce</li> <li>SAP</li> <li>ServiceNow</li> <li>Supertab</li> <li>TCS</li> <li>Typeface</li> <li>UKG</li> <li>UiPath</li> <li>Weights &amp; Biases</li> <li>Wipro</li> <li>Workday</li> <li>Writer</li> <li>Zeotap</li> <li>Zoom</li> </ul>"},{"location":"specification/","title":"Agent2Agent (A2A) Protocol Specification","text":"<p>Version: <code>0.1.0</code></p>"},{"location":"specification/#1-introduction","title":"1. Introduction","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to facilitate communication and interoperability between independent, potentially opaque AI agent systems. In an ecosystem where agents might be built using different frameworks, languages, or by different vendors, A2A provides a common language and interaction model.</p> <p>This document provides the detailed technical specification for the A2A protocol. Its primary goal is to enable agents to:</p> <ul> <li>Discover each other's capabilities.</li> <li>Negotiate interaction modalities (text, files, structured data).</li> <li>Manage collaborative tasks.</li> <li>Securely exchange information to achieve user goals without needing access to each other's internal state, memory, or tools.</li> </ul>"},{"location":"specification/#11-key-goals-of-a2a","title":"1.1. Key Goals of A2A","text":"<ul> <li>Interoperability: Bridge the communication gap between disparate agentic systems.</li> <li>Collaboration: Enable agents to delegate tasks, exchange context, and work together on complex user requests.</li> <li>Discovery: Allow agents to dynamically find and understand the capabilities of other agents.</li> <li>Flexibility: Support various interaction modes including synchronous request/response, streaming for real-time updates, and asynchronous push notifications for long-running tasks.</li> <li>Security: Facilitate secure communication patterns suitable for enterprise environments, relying on standard web security practices.</li> <li>Asynchronicity: Natively support long-running tasks and interactions that may involve human-in-the-loop scenarios.</li> </ul>"},{"location":"specification/#12-guiding-principles","title":"1.2. Guiding Principles","text":"<ul> <li>Simple: Reuse existing, well-understood standards (HTTP, JSON-RPC 2.0, Server-Sent Events).</li> <li>Enterprise Ready: Address authentication, authorization, security, privacy, tracing, and monitoring by aligning with established enterprise practices.</li> <li>Async First: Designed for (potentially very) long-running tasks and human-in-the-loop interactions.</li> <li>Modality Agnostic: Support exchange of diverse content types including text, audio/video (via file references), structured data/forms, and potentially embedded UI components (e.g., iframes referenced in parts).</li> <li>Opaque Execution: Agents collaborate based on declared capabilities and exchanged information, without needing to share their internal thoughts, plans, or tool implementations.</li> </ul> <p>For a broader understanding of A2A's purpose and benefits, see What is A2A?.</p>"},{"location":"specification/#2-core-concepts-summary","title":"2. Core Concepts Summary","text":"<p>A2A revolves around several key concepts. For detailed explanations, please refer to the Key Concepts guide.</p> <ul> <li>A2A Client: An application or agent that initiates requests to an A2A Server on behalf of a user or another system.</li> <li>A2A Server (Remote Agent): An agent or agentic system that exposes an A2A-compliant HTTP endpoint, processing tasks and providing responses.</li> <li>Agent Card: A JSON metadata document published by an A2A Server, describing its identity, capabilities, skills, service endpoint, and authentication requirements.</li> <li>Task: The fundamental unit of work managed by A2A, identified by a unique ID. Tasks are stateful and progress through a defined lifecycle.</li> <li>Message: A communication turn within a Task, having a <code>role</code> (\"user\" or \"agent\") and containing one or more <code>Parts</code>.</li> <li>Part: The smallest unit of content within a Message or Artifact (e.g., <code>TextPart</code>, <code>FilePart</code>, <code>DataPart</code>).</li> <li>Artifact: An output (e.g., a document, image, structured data) generated by the agent as a result of a task, composed of <code>Parts</code>.</li> <li>Streaming (SSE): Real-time, incremental updates for tasks (status changes, artifact chunks) delivered via Server-Sent Events.</li> <li>Push Notifications: Asynchronous task updates delivered via server-initiated HTTP POST requests to a client-provided webhook URL, for long-running or disconnected scenarios.</li> <li>Session: An optional, client-generated identifier to logically group related tasks.</li> </ul>"},{"location":"specification/#3-transport-and-format","title":"3. Transport and Format","text":""},{"location":"specification/#31-transport-protocol","title":"3.1. Transport Protocol","text":"<ul> <li>A2A communication MUST occur over HTTP(S).</li> <li>The A2A Server exposes its service at a URL defined in its <code>AgentCard</code>.</li> </ul>"},{"location":"specification/#32-data-format","title":"3.2. Data Format","text":"<p>A2A uses JSON-RPC 2.0 as the payload format for all requests and responses (excluding the SSE stream wrapper).</p> <ul> <li>Client requests and server responses MUST adhere to the JSON-RPC 2.0 specification.</li> <li>The <code>Content-Type</code> header for HTTP requests and responses containing JSON-RPC payloads MUST be <code>application/json</code>.</li> </ul>"},{"location":"specification/#33-streaming-transport-server-sent-events","title":"3.3. Streaming Transport (Server-Sent Events)","text":"<p>When streaming is used for methods like <code>tasks/sendSubscribe</code> or <code>tasks/resubscribe</code>:</p> <ul> <li>The server responds with an HTTP <code>200 OK</code> status and a <code>Content-Type</code> header of <code>text/event-stream</code>.</li> <li>The body of this HTTP response contains a stream of Server-Sent Events (SSE) as defined by the W3C.</li> <li>Each SSE <code>data</code> field contains a complete JSON-RPC 2.0 Response object (specifically, a <code>SendTaskStreamingResponse</code>).</li> </ul>"},{"location":"specification/#4-authentication-and-authorization","title":"4. Authentication and Authorization","text":"<p>A2A treats agents as standard enterprise applications, relying on established web security practices. Identity information is not transmitted within A2A JSON-RPC payloads; it is handled at the HTTP transport layer.</p> <p>For a comprehensive guide on enterprise security aspects, see Enterprise-Ready Features.</p>"},{"location":"specification/#41-transport-security","title":"4.1. Transport Security","text":"<p>As stated in section 3.1, production deployments MUST use HTTPS. Implementations SHOULD use modern TLS configurations (TLS 1.2+ recommended) with strong cipher suites.</p>"},{"location":"specification/#42-server-identity-verification","title":"4.2. Server Identity Verification","text":"<p>A2A Clients SHOULD verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake.</p>"},{"location":"specification/#43-clientuser-identity-authentication-process","title":"4.3. Client/User Identity &amp; Authentication Process","text":"<ol> <li>Discovery of Requirements: The client discovers the server's required authentication schemes via the <code>authentication</code> field in the <code>AgentCard</code>. Scheme names often align with OpenAPI Authentication methods (e.g., \"Bearer\" for OAuth 2.0 tokens, \"Basic\" for Basic Auth, \"ApiKey\" for API keys).</li> <li>Credential Acquisition (Out-of-Band): The client obtains the necessary credentials (e.g., API keys, OAuth tokens, JWTs) through an out-of-band process specific to the required authentication scheme and the identity provider. This process is outside the scope of the A2A protocol itself.</li> <li>Credential Transmission: The client includes these credentials in the appropriate HTTP headers (e.g., <code>Authorization: Bearer &lt;token&gt;</code>, <code>X-API-Key: &lt;value&gt;</code>) of every A2A request sent to the server.</li> </ol>"},{"location":"specification/#44-server-responsibilities-for-authentication","title":"4.4. Server Responsibilities for Authentication","text":"<p>The A2A Server:</p> <ul> <li>MUST authenticate every incoming request based on the provided HTTP credentials and its declared authentication requirements from its Agent Card.</li> <li>SHOULD use standard HTTP status codes like <code>401 Unauthorized</code> or <code>403 Forbidden</code> for authentication challenges or rejections.</li> <li>SHOULD include relevant HTTP headers (e.g., <code>WWW-Authenticate</code>) with <code>401 Unauthorized</code> responses to indicate the required authentication scheme(s), guiding the client.</li> </ul>"},{"location":"specification/#45-in-task-authentication-secondary-credentials","title":"4.5. In-Task Authentication (Secondary Credentials)","text":"<p>If an agent, during the execution of a task, requires additional credentials for a different system or resource (e.g., to access a specific tool on behalf of the user that requires its own auth):</p> <ol> <li>It SHOULD transition the A2A task to the <code>input-required</code> state (see <code>TaskState</code>).</li> <li>The accompanying <code>TaskStatus.message</code> (often a <code>DataPart</code>) SHOULD provide details about the required secondary authentication, potentially using an <code>AuthenticationInfo</code>-like structure to describe the need.</li> <li>The A2A Client then obtains these new credentials out-of-band and provides them in a subsequent <code>tasks/send</code> or <code>tasks/sendSubscribe</code> request. How these credentials are used (e.g., passed as data within the A2A message if the agent is proxying, or used by the client to interact directly with the secondary system) depends on the specific scenario.</li> </ol>"},{"location":"specification/#46-authorization","title":"4.6. Authorization","text":"<p>Once a client is authenticated, the A2A Server is responsible for authorizing the request based on the authenticated client/user identity and its own policies. Authorization logic is implementation-specific and MAY be enforced based on:</p> <ul> <li>The specific skills requested (e.g., as identified by <code>AgentSkill.id</code> from the Agent Card).</li> <li>The actions attempted within the task.</li> <li>Data access policies relevant to the resources the agent manages.</li> <li>OAuth scopes associated with the presented token, if applicable.</li> </ul> <p>Servers should implement the principle of least privilege.</p>"},{"location":"specification/#5-agent-discovery-the-agent-card","title":"5. Agent Discovery: The Agent Card","text":""},{"location":"specification/#51-purpose","title":"5.1. Purpose","text":"<p>A2A Servers MUST make an Agent Card available. The Agent Card is a JSON document that describes the server's identity, capabilities, skills, service endpoint URL, and how clients should authenticate and interact with it. Clients use this information for discovering suitable agents and for configuring their interactions.</p> <p>For more on discovery strategies, see the Agent Discovery guide.</p>"},{"location":"specification/#52-discovery-mechanisms","title":"5.2. Discovery Mechanisms","text":"<p>Clients can find Agent Cards through various methods, including but not limited to:</p> <ul> <li>Well-Known URI: Accessing a predefined path on the agent's domain (see Section 5.3).</li> <li>Registries/Catalogs: Querying curated catalogs or registries of agents (which might be enterprise-specific, public, or domain-specific).</li> <li>Direct Configuration: Clients may be pre-configured with the Agent Card URL or the card content itself.</li> </ul>"},{"location":"specification/#53-recommended-location","title":"5.3. Recommended Location","text":"<p>If using the well-known URI strategy, the recommended location for an agent's Agent Card is: <code>https://{server_domain}/.well-known/agent.json</code> This follows the principles of RFC 8615 for well-known URIs.</p>"},{"location":"specification/#54-security-of-agent-cards","title":"5.4. Security of Agent Cards","text":"<p>Agent Cards themselves might contain information that is considered sensitive (e.g., the URL of an internal-only agent, or scheme-specific information in <code>authentication.credentials</code>).</p> <ul> <li>If an Agent Card contains sensitive information, the endpoint serving the card MUST be protected by appropriate access controls (e.g., mTLS, network restrictions, authentication required to fetch the card).</li> <li>It is generally NOT RECOMMENDED to include plaintext secrets (like static API keys) directly in an Agent Card. Prefer authentication schemes where clients obtain dynamic credentials out-of-band. If <code>authentication.credentials</code> is used, it should be for non-secret information like OAuth flow URLs or API key names (not values).</li> </ul>"},{"location":"specification/#55-agentcard-object-structure","title":"5.5. <code>AgentCard</code> Object Structure","text":"<pre><code>// An AgentCard conveys key information about an A2A Server:\n// - Overall identity and descriptive details.\n// - Service endpoint URL.\n// - Supported A2A protocol capabilities (streaming, push notifications).\n// - Authentication requirements.\n// - Default input/output content types (MIME types).\n// - A list of specific skills the agent offers.\ninterface AgentCard {\n  // Human-readable name of the agent (e.g., \"Recipe Advisor Agent\").\n  name: string;\n  // A human-readable description of the agent and its general purpose.\n  // [CommonMark](https://commonmark.org/) MAY be used for rich text formatting.\n  // (e.g., \"This agent helps users find recipes, plan meals, and get cooking instructions.\")\n  description?: string | null;\n  // The base URL endpoint for the agent's A2A service (where JSON-RPC requests are sent).\n  // Must be an absolute HTTPS URL for production (e.g., `https://agent.example.com/a2a/api`).\n  // HTTP MAY be used for local development/testing only.\n  url: string;\n  // Information about the organization or entity providing the agent.\n  provider?: AgentProvider | null;\n  // Version string for the agent or its A2A implementation\n  // (format is defined by the provider, e.g., \"1.0.0\", \"2023-10-26-beta\").\n  version: string;\n  // URL pointing to human-readable documentation for the agent (e.g., API usage, detailed skill descriptions).\n  documentationUrl?: string | null;\n  // Specifies optional A2A protocol features supported by this agent.\n  capabilities: AgentCapabilities;\n  // Authentication schemes required to interact with the agent's `url` endpoint.\n  // If `null`, omitted, or an empty `schemes` array, no A2A-level authentication is explicitly advertised\n  // (NOT recommended for production; other security like network ACLs might still apply).\n  authentication?: AgentAuthentication | null;\n  // Array of [MIME types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)\n  // the agent generally accepts as input across all skills, unless overridden by a specific skill.\n  // Default if omitted: `[\"text/plain\"]`. Example: `[\"text/plain\", \"image/png\"]`.\n  defaultInputModes?: string[];\n  // Array of MIME types the agent generally produces as output across all skills, unless overridden by a specific skill.\n  // Default if omitted: `[\"text/plain\"]`. Example: `[\"text/plain\", \"application/json\"]`.\n  defaultOutputModes?: string[];\n  // An array of specific skills or capabilities the agent offers.\n  // Must contain at least one skill if the agent is expected to perform actions beyond simple presence.\n  skills: AgentSkill[];\n}\n</code></pre> Field Name Type Required Description <code>name</code> <code>string</code> Yes Human-readable name of the agent. <code>description</code> <code>string</code> | <code>null</code> No Human-readable description. CommonMark MAY be used. <code>url</code> <code>string</code> Yes Base URL for the agent's A2A service. Must be absolute. HTTPS for production. <code>provider</code> <code>AgentProvider</code> | <code>null</code> No Information about the agent's provider. <code>version</code> <code>string</code> Yes Agent or A2A implementation version string. <code>documentationUrl</code> <code>string</code> | <code>null</code> No URL to human-readable documentation for the agent. <code>capabilities</code> <code>AgentCapabilities</code> Yes Specifies optional A2A protocol features supported (e.g., streaming, push notifications). <code>authentication</code> <code>AgentAuthentication</code> | <code>null</code> No Authentication schemes required. <code>null</code> or empty implies no A2A-advertised auth (not recommended for production). <code>defaultInputModes</code> <code>string[]</code> No Default accepted input MIME types. Defaults to <code>[\"text/plain\"]</code> if omitted. <code>defaultOutputModes</code> <code>string[]</code> No Default produced output MIME types. Defaults to <code>[\"text/plain\"]</code> if omitted. <code>skills</code> <code>AgentSkill[]</code> Yes Array of skills. Must have at least one if the agent performs actions."},{"location":"specification/#551-agentprovider-object","title":"5.5.1. <code>AgentProvider</code> Object","text":"<p>Information about the organization or entity providing the agent.</p> <pre><code>interface AgentProvider {\n  // Name of the organization or entity.\n  organization: string;\n  // URL for the provider's organization website or relevant contact page.\n  url?: string | null;\n}\n</code></pre> Field Name Type Required Description <code>organization</code> <code>string</code> Yes Name of the organization/entity. <code>url</code> <code>string</code> | <code>null</code> No URL for the provider's website/contact."},{"location":"specification/#552-agentcapabilities-object","title":"5.5.2. <code>AgentCapabilities</code> Object","text":"<p>Specifies optional A2A protocol features supported by the agent.</p> <pre><code>interface AgentCapabilities {\n  // If `true`, the agent supports `tasks/sendSubscribe` and `tasks/resubscribe` for real-time\n  // updates via Server-Sent Events (SSE). Default: `false`.\n  streaming?: boolean;\n  // If `true`, the agent supports `tasks/pushNotification/set` and `tasks/pushNotification/get`\n  // for asynchronous task updates via webhooks. Default: `false`.\n  pushNotifications?: boolean;\n  // If `true`, the agent may include a detailed history of status changes\n  // within the `Task` object (future enhancement; specific mechanism TBD). Default: `false`.\n  stateTransitionHistory?: boolean;\n}\n</code></pre> Field Name Type Required Default Description <code>streaming</code> <code>boolean</code> No <code>false</code> Indicates support for SSE streaming methods (<code>tasks/sendSubscribe</code>, <code>tasks/resubscribe</code>). <code>pushNotifications</code> <code>boolean</code> No <code>false</code> Indicates support for push notification methods (<code>tasks/pushNotification/*</code>). <code>stateTransitionHistory</code> <code>boolean</code> No <code>false</code> Placeholder for future feature: exposing detailed task status change history."},{"location":"specification/#553-agentauthentication-object","title":"5.5.3. <code>AgentAuthentication</code> Object","text":"<p>Describes the authentication requirements for accessing the agent's <code>url</code> endpoint.</p> <pre><code>interface AgentAuthentication {\n  // Array of authentication scheme names supported/required by the agent's endpoint\n  // (e.g., \"Bearer\", \"Basic\", \"OAuth2\", \"ApiKey\").\n  // Standard names (e.g., from OpenAPI specification, IANA registry) SHOULD be used where applicable.\n  // An empty array means no specific A2A-level schemes are advertised.\n  schemes: string[];\n  // Optional field, MAY contain non-secret, scheme-specific information.\n  // Examples: For \"OAuth2\", this could be a JSON string with `tokenUrl`, `authorizationUrl`, `scopes`.\n  // For \"ApiKey\", it could specify the header name (`in: \"header\"`, `name: \"X-Custom-API-Key\"`).\n  // **CRITICAL**: This field MUST NOT contain plaintext secrets (e.g., actual API key values, passwords).\n  // If the Agent Card itself needs to be protected due to this field containing sensitive URLs\n  // or configuration, the endpoint serving the Agent Card MUST be secured.\n  credentials?: string | null; // E.g., A JSON string parsable by the client for scheme details.\n}\n</code></pre> Field Name Type Required Description <code>schemes</code> <code>string[]</code> Yes Array of auth scheme names (e.g., \"Bearer\", \"OAuth2\", \"ApiKey\"). Empty array means no A2A-advertised schemes. <code>credentials</code> <code>string</code> | <code>null</code> No Optional non-secret, scheme-specific configuration info (e.g., OAuth URLs, API key header name). MUST NOT contain plaintext secrets. Secure the Agent Card if this field implies sensitivity."},{"location":"specification/#554-agentskill-object","title":"5.5.4. <code>AgentSkill</code> Object","text":"<p>Describes a specific capability, function, or area of expertise the agent can perform or address.</p> <pre><code>interface AgentSkill {\n  // A unique identifier for this skill within the context of this agent\n  // (e.g., \"currency-converter\", \"generate-image-from-prompt\", \"summarize-text-v2\").\n  // Clients MAY use this ID to request a specific skill if the agent supports such dispatch.\n  id: string;\n  // Human-readable name of the skill (e.g., \"Currency Conversion Service\", \"Image Generation AI\").\n  name: string;\n  // Detailed description of what the skill does, its purpose, and any important considerations.\n  // [CommonMark](https://commonmark.org/) MAY be used for rich text formatting.\n  description?: string | null;\n  // Array of keywords or categories for discoverability and categorization\n  // (e.g., [\"finance\", \"conversion\"], [\"media\", \"generative ai\", \"image\"]).\n  tags?: string[] | null;\n  // Array of example prompts, inputs, or use cases illustrating how to use this skill\n  // (e.g., [\"convert 100 USD to EUR\", \"generate a photorealistic image of a cat wearing a wizard hat\"]).\n  // These help clients (and potentially end-users or other agents) understand how to formulate requests for this skill.\n  examples?: string[] | null;\n  // Overrides `agentCard.defaultInputModes` specifically for this skill.\n  // If `null` or omitted, the agent's `defaultInputModes` apply.\n  inputModes?: string[] | null; // Array of MIME types\n  // Overrides `agentCard.defaultOutputModes` specifically for this skill.\n  // If `null` or omitted, the agent's `defaultOutputModes` apply.\n  outputModes?: string[] | null; // Array of MIME types\n}\n</code></pre> Field Name Type Required Description <code>id</code> <code>string</code> Yes Unique skill identifier within this agent. <code>name</code> <code>string</code> Yes Human-readable skill name. <code>description</code> <code>string</code> | <code>null</code> No Detailed skill description. CommonMark MAY be used. <code>tags</code> <code>string[]</code> | <code>null</code> No Keywords/categories for discoverability. <code>examples</code> <code>string[]</code> | <code>null</code> No Example prompts or use cases demonstrating skill usage. <code>inputModes</code> <code>string[]</code> | <code>null</code> No Overrides <code>defaultInputModes</code> for this specific skill. Accepted MIME types. <code>outputModes</code> <code>string[]</code> | <code>null</code> No Overrides <code>defaultOutputModes</code> for this specific skill. Produced MIME types."},{"location":"specification/#56-sample-agent-card","title":"5.6. Sample Agent Card","text":"<pre><code>{\n  \"name\": \"GeoSpatial Route Planner Agent\",\n  \"description\": \"Provides advanced route planning, traffic analysis, and custom map generation services. This agent can calculate optimal routes, estimate travel times considering real-time traffic, and create personalized maps with points of interest.\",\n  \"url\": \"https://georoute-agent.example.com/a2a/v1\",\n  \"provider\": {\n    \"organization\": \"Example Geo Services Inc.\",\n    \"url\": \"https://www.examplegeoservices.com\"\n  },\n  \"version\": \"1.2.0\",\n  \"documentationUrl\": \"https://docs.examplegeoservices.com/georoute-agent/api\",\n  \"capabilities\": {\n    \"streaming\": true,\n    \"pushNotifications\": true,\n    \"stateTransitionHistory\": false\n  },\n  \"authentication\": {\n    \"schemes\": [\"OAuth2\"],\n    \"credentials\": \"{\\\"authorizationUrl\\\": \\\"https://auth.examplegeoservices.com/authorize\\\", \\\"tokenUrl\\\": \\\"https://auth.examplegeoservices.com/token\\\", \\\"scopes\\\": {\\\"route:plan\\\": \\\"Allows planning new routes.\\\", \\\"map:custom\\\": \\\"Allows creating and managing custom maps.\\\"}}\"\n  },\n  \"defaultInputModes\": [\"application/json\", \"text/plain\"],\n  \"defaultOutputModes\": [\"application/json\", \"image/png\"],\n  \"skills\": [\n    {\n      \"id\": \"route-optimizer-traffic\",\n      \"name\": \"Traffic-Aware Route Optimizer\",\n      \"description\": \"Calculates the optimal driving route between two or more locations, taking into account real-time traffic conditions, road closures, and user preferences (e.g., avoid tolls, prefer highways).\",\n      \"tags\": [\"maps\", \"routing\", \"navigation\", \"directions\", \"traffic\"],\n      \"examples\": [\n        \"Plan a route from '1600 Amphitheatre Parkway, Mountain View, CA' to 'San Francisco International Airport' avoiding tolls.\",\n        \"{\\\"origin\\\": {\\\"lat\\\": 37.422, \\\"lng\\\": -122.084}, \\\"destination\\\": {\\\"lat\\\": 37.7749, \\\"lng\\\": -122.4194}, \\\"preferences\\\": [\\\"avoid_ferries\\\"]}\"\n      ],\n      \"inputModes\": [\"application/json\", \"text/plain\"],\n      \"outputModes\": [\n        \"application/json\",\n        \"application/vnd.geo+json\",\n        \"text/html\"\n      ]\n    },\n    {\n      \"id\": \"custom-map-generator\",\n      \"name\": \"Personalized Map Generator\",\n      \"description\": \"Creates custom map images or interactive map views based on user-defined points of interest, routes, and style preferences. Can overlay data layers.\",\n      \"tags\": [\"maps\", \"customization\", \"visualization\", \"cartography\"],\n      \"examples\": [\n        \"Generate a map of my upcoming road trip with all planned stops highlighted.\",\n        \"Show me a map visualizing all coffee shops within a 1-mile radius of my current location.\"\n      ],\n      \"inputModes\": [\"application/json\"],\n      \"outputModes\": [\n        \"image/png\",\n        \"image/jpeg\",\n        \"application/json\",\n        \"text/html\"\n      ]\n    }\n  ]\n}\n</code></pre>"},{"location":"specification/#6-protocol-data-objects","title":"6. Protocol Data Objects","text":"<p>These objects define the structure of data exchanged within the JSON-RPC methods of the A2A protocol.</p>"},{"location":"specification/#61-task-object","title":"6.1. <code>Task</code> Object","text":"<p>Represents the stateful unit of work being processed by the A2A Server for an A2A Client. A task encapsulates the entire interaction related to a specific goal or request.</p> <pre><code>interface Task {\n  // A unique identifier for the task. This ID is typically generated by the client\n  // when initiating the task and MUST be used by the server to refer to this task.\n  // It should be sufficiently unique (e.g., a UUID v4).\n  id: string;\n  // An optional, client-generated identifier used to group related tasks into a logical session.\n  // Useful for maintaining context across multiple, sequential, or related tasks.\n  sessionId?: string | null;\n  // The current status of the task, including its lifecycle state, an optional associated message,\n  // and a timestamp.\n  status: TaskStatus;\n  // An array of outputs (artifacts) generated by the agent for this task.\n  // This array can be populated incrementally, especially during streaming.\n  // Artifacts represent the tangible results of the task.\n  artifacts?: Artifact[] | null;\n  // An optional array of recent messages exchanged within this task,\n  // ordered chronologically (oldest first).\n  // This history is included if requested by the client via the `historyLength` parameter\n  // in `TaskSendParams` or `TaskQueryParams`.\n  history?: Message[] | null;\n  // Arbitrary key-value metadata associated with the task.\n  // Keys SHOULD be strings; values can be any valid JSON type (string, number, boolean, array, object).\n  // This can be used for application-specific data, tracing info, etc.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Description <code>id</code> <code>string</code> Yes Unique task identifier (e.g., UUID), typically client-generated. <code>sessionId</code> <code>string</code> | <code>null</code> No Optional client-generated ID to group related tasks into a session. <code>status</code> <code>TaskStatus</code> Yes Current status of the task (state, message, timestamp). <code>artifacts</code> <code>Artifact[]</code> | <code>null</code> No Array of outputs generated by the agent for this task. <code>history</code> <code>Message[]</code> | <code>null</code> No Optional array of recent messages exchanged, if requested by <code>historyLength</code>. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Arbitrary key-value metadata associated with the task."},{"location":"specification/#62-taskstatus-object","title":"6.2. <code>TaskStatus</code> Object","text":"<p>Represents the current state and associated context (e.g., a message from the agent) of a <code>Task</code>.</p> <pre><code>interface TaskStatus {\n  // The current lifecycle state of the task.\n  state: TaskState;\n  // An optional message associated with the current status.\n  // This could be a progress update from the agent, a prompt for more input,\n  // a summary of the final result, or an error message.\n  message?: Message | null;\n  // The date and time (UTC is STRONGLY recommended) when this status was recorded by the server.\n  // Format: ISO 8601 `date-time` string (e.g., \"2023-10-27T10:00:00Z\").\n  timestamp?: string | null;\n}\n</code></pre> Field Name Type Required Description <code>state</code> <code>TaskState</code> Yes Current lifecycle state of the task. <code>message</code> <code>Message</code> | <code>null</code> No Optional message providing context for the current status. <code>timestamp</code> <code>string</code> (ISO 8601) | <code>null</code> No Timestamp (UTC recommended) when this status was recorded."},{"location":"specification/#63-taskstate-enum","title":"6.3. <code>TaskState</code> Enum","text":"<p>Defines the possible lifecycle states of a <code>Task</code>.</p> <pre><code>type TaskState =\n  | 'submitted' // Task received by server, acknowledged, but processing has not yet actively started.\n  | 'working' // Task is actively being processed by the agent.\n  | 'input-required' // Agent requires additional input from the client/user to proceed. (Task is paused)\n  | 'completed' // Task finished successfully. (Terminal state)\n  | 'canceled' // Task was canceled by the client or potentially by the server. (Terminal state)\n  | 'failed' // Task terminated due to an error during processing. (Terminal state)\n  | 'unknown'; // The state of the task cannot be determined (e.g., task ID invalid or expired). (Effectively a terminal state from client's PoV for that ID)\n</code></pre> Value Description Terminal? <code>submitted</code> Task received by the server and acknowledged, but processing has not yet actively started. No <code>working</code> Task is actively being processed by the agent. Client may expect further updates or a terminal state. No <code>input-required</code> Agent requires additional input from the client/user to proceed. The task is effectively paused. No (Pause) <code>completed</code> Task finished successfully. Results are typically available in <code>Task.artifacts</code> or <code>TaskStatus.message</code>. Yes <code>canceled</code> Task was canceled (e.g., by a <code>tasks/cancel</code> request or server-side policy). Yes <code>failed</code> Task terminated due to an error during processing. <code>TaskStatus.message</code> may contain error details. Yes <code>unknown</code> The state of the task cannot be determined (e.g., task ID is invalid, unknown, or has expired). Yes"},{"location":"specification/#64-message-object","title":"6.4. <code>Message</code> Object","text":"<p>Represents a single communication turn or a piece of contextual information within a <code>Task</code>. Messages are used for instructions, prompts, replies, and status updates.</p> <pre><code>interface Message {\n  // Indicates the sender of the message:\n  // \"user\" for messages originating from the A2A Client (acting on behalf of an end-user or system).\n  // \"agent\" for messages originating from the A2A Server (the remote agent).\n  role: 'user' | 'agent';\n  // An array containing the content of the message, broken down into one or more parts.\n  // A message MUST contain at least one part.\n  // Using multiple parts allows for rich, multi-modal content (e.g., text accompanying an image).\n  parts: Part[];\n  // Arbitrary key-value metadata associated with the message.\n  // Keys SHOULD be strings; values can be any valid JSON type.\n  // Useful for timestamps, source identifiers, language codes, etc.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Description <code>role</code> <code>\"user\"</code> | <code>\"agent\"</code> Yes Indicates the sender: <code>\"user\"</code> (from A2A Client) or <code>\"agent\"</code> (from A2A Server). <code>parts</code> <code>Part[]</code> Yes Array of content parts. Must contain at least one part. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Arbitrary key-value metadata associated with this message."},{"location":"specification/#65-part-union-type","title":"6.5. <code>Part</code> Union Type","text":"<p>Represents a distinct piece of content within a <code>Message</code> or <code>Artifact</code>. A <code>Part</code> object is a discriminated union, identified by its mandatory <code>type</code> field. All <code>Part</code> types also include an optional <code>metadata</code> field (<code>Record&lt;string, any&gt; | null</code>) for part-specific metadata.</p> <p>It MUST be one of the following:</p>"},{"location":"specification/#651-textpart-object","title":"6.5.1. <code>TextPart</code> Object","text":"<p>For conveying plain textual content.</p> <pre><code>interface TextPart {\n  type: 'text'; // Discriminator\n  text: string; // The actual textual content.\n  metadata?: Record&lt;string, any&gt; | null; // Optional metadata (e.g., language, formatting hints if any)\n}\n</code></pre> Field Name Type Required Description <code>type</code> <code>\"text\"</code> (literal) Yes Identifies this part as textual content. <code>text</code> <code>string</code> Yes The textual content of the part. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Optional metadata specific to this text part."},{"location":"specification/#652-filepart-object","title":"6.5.2. <code>FilePart</code> Object","text":"<p>For conveying file-based content.</p> <pre><code>interface FilePart {\n  type: 'file'; // Discriminator\n  file: FileContent; // Contains the file details and data (or reference).\n  metadata?: Record&lt;string, any&gt; | null; // Optional metadata (e.g., purpose of the file)\n}\n</code></pre> Field Name Type Required Description <code>type</code> <code>\"file\"</code> (literal) Yes Identifies this part as file content. <code>file</code> <code>FileContent</code> Yes Contains the file details and data/reference. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Optional metadata specific to this file part."},{"location":"specification/#653-datapart-object","title":"6.5.3. <code>DataPart</code> Object","text":"<p>For conveying structured JSON data. Useful for forms, parameters, or any machine-readable information.</p> <pre><code>interface DataPart {\n  type: 'data'; // Discriminator\n  // The structured JSON data payload. This can be any valid JSON object or array.\n  // The schema of this data is application-defined and may be implicitly understood\n  // by the interacting agents or explicitly described (e.g., via a JSON Schema reference\n  // in the `metadata` or associated `AgentSkill`).\n  data: Record&lt;string, any&gt; | any[];\n  metadata?: Record&lt;string, any&gt; | null; // Optional metadata (e.g., schema URL, version)\n}\n</code></pre> Field Name Type Required Description <code>type</code> <code>\"data\"</code> (literal) Yes Identifies this part as structured data. <code>data</code> <code>Record&lt;string, any&gt;</code> | <code>any[]</code> Yes The structured JSON data payload (an object or an array). <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Optional metadata specific to this data part (e.g., reference to a schema)."},{"location":"specification/#66-filecontent-object","title":"6.6. <code>FileContent</code> Object","text":"<p>Represents the data or reference for a file, used within a <code>FilePart</code>.</p> <pre><code>interface FileContent {\n  // The original filename, if known (e.g., \"document.pdf\", \"avatar.png\").\n  name?: string | null;\n  // The [MIME type](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)\n  // of the file (e.g., \"application/pdf\", \"image/png\"). Strongly recommended for proper handling.\n  mimeType?: string | null;\n  // Base64 encoded string of the raw file content.\n  // Use this for embedding small to medium-sized files directly.\n  bytes?: string | null; // Base64 string\n  // A URI (absolute URL is STRONGLY recommended) pointing to the file content.\n  // Accessibility of this URI depends on the context (e.g., public URL, pre-signed URL, internal URL).\n  // The client and server must have a way to resolve and access this URI if used.\n  uri?: string | null;\n\n  // Constraint: If file content is being transmitted, exactly one of `bytes` or `uri` MUST be non-null.\n  // Both MAY be `null` or absent if the `FilePart` is merely representing a file reference\n  // without transmitting its content in the current message (e.g., referring to a previously uploaded file).\n}\n</code></pre> Field Name Type Required Description <code>name</code> <code>string</code> | <code>null</code> No Original filename (e.g., \"report.pdf\"). <code>mimeType</code> <code>string</code> | <code>null</code> No MIME type (e.g., <code>image/png</code>). Strongly recommended. <code>bytes</code> <code>string</code> | <code>null</code> Conditionally (See Constraint) Base64 encoded file content. <code>uri</code> <code>string</code> | <code>null</code> Conditionally (See Constraint) URI (absolute URL strongly recommended) to file content. Accessibility is context-dependent. <p>Constraint: If file content is being transmitted, exactly one of <code>bytes</code> or <code>uri</code> MUST be provided and non-null. Both MAY be <code>null</code> or absent if the <code>FilePart</code> is only a reference or metadata about a file whose content is not being transferred in this specific part.</p>"},{"location":"specification/#67-artifact-object","title":"6.7. <code>Artifact</code> Object","text":"<p>Represents a tangible output generated by the agent during a task. Artifacts are the results or products of the agent's work.</p> <pre><code>interface Artifact {\n  // A descriptive name for the artifact (e.g., \"Quarterly Sales Report.pdf\", \"Generated Logo Design\", \"analysis_results.json\").\n  // This name might be used by the client for display or identification.\n  name?: string | null;\n  // A human-readable description of the artifact. [CommonMark](https://commonmark.org/) MAY be used.\n  description?: string | null;\n  // An array containing the content of the artifact, broken down into one or more parts.\n  // An artifact MUST contain at least one part.\n  // Using multiple parts allows for complex artifacts (e.g., a report with embedded images or data tables).\n  parts: Part[];\n  // A non-negative integer index for ordering artifacts or identifying artifact chunks during streaming.\n  // Multiple artifacts (or artifact updates) can share the same index if they represent parts of the same logical output\n  // that are being streamed or delivered separately.\n  // Default: 0 if omitted.\n  index?: number;\n  // Used with streaming (`TaskArtifactUpdateEvent`):\n  // If `true`, indicates this update's `parts` should be appended to the content of the artifact\n  // currently identified by the same `index` value. This is useful for streaming textual data or\n  // appending elements to a list in a `DataPart`.\n  // If `false` or `null` (or omitted), this update replaces the artifact content at the given `index`.\n  // This field is typically `false` for the first chunk of a streamed artifact.\n  append?: boolean | null;\n  // Used with streaming (`TaskArtifactUpdateEvent`):\n  // If `true`, indicates this is the final update/chunk for the artifact at this `index`.\n  // Signals the end of a streamed file or data structure.\n  lastChunk?: boolean | null;\n  // Arbitrary key-value metadata associated with the artifact.\n  // Keys SHOULD be strings; values can be any valid JSON type.\n  // Useful for creation timestamps, versioning info, checksums, etc.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Default Description <code>name</code> <code>string</code> | <code>null</code> No <code>null</code> Descriptive name for the artifact. <code>description</code> <code>string</code> | <code>null</code> No <code>null</code> Human-readable description of the artifact. <code>parts</code> <code>Part[]</code> Yes Content of the artifact, as one or more <code>Part</code> objects. Must have at least one. <code>index</code> <code>integer</code> No <code>0</code> Non-negative index for ordering artifacts or identifying chunks during streaming. <code>append</code> <code>boolean</code> | <code>null</code> No <code>false</code> In streaming (<code>TaskArtifactUpdateEvent</code>), <code>true</code> means append parts to artifact at <code>index</code>; <code>false</code> (default) means replace. <code>lastChunk</code> <code>boolean</code> | <code>null</code> No <code>false</code> In streaming (<code>TaskArtifactUpdateEvent</code>), <code>true</code> indicates this is the final update for the artifact at this <code>index</code>. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No <code>null</code> Arbitrary key-value metadata associated with the artifact."},{"location":"specification/#68-pushnotificationconfig-object","title":"6.8. <code>PushNotificationConfig</code> Object","text":"<p>Configuration provided by the client to the server for sending asynchronous push notifications about task updates.</p> <pre><code>interface PushNotificationConfig {\n  // The absolute HTTPS webhook URL where the A2A Server should POST task updates.\n  // This URL MUST be HTTPS for security.\n  url: string;\n  // An optional, client-generated opaque token (e.g., a secret, a task-specific identifier, or a nonce).\n  // The A2A Server SHOULD include this token in the notification request it sends to the `url`\n  // (e.g., in a custom HTTP header like `X-A2A-Notification-Token` or similar).\n  // This allows the client's webhook receiver to validate the relevance and authenticity of the notification.\n  token?: string | null;\n  // Authentication details the A2A Server needs to use when calling the client's `url`.\n  // The client's webhook endpoint defines these requirements. This tells the A2A Server how to authenticate *itself* to the client's webhook.\n  authentication?: AuthenticationInfo | null;\n}\n</code></pre> Field Name Type Required Description <code>url</code> <code>string</code> Yes Absolute HTTPS webhook URL for the A2A Server to POST task updates to. <code>token</code> <code>string</code> | <code>null</code> No Optional client-generated opaque token for the client's webhook receiver to validate the notification (e.g., server includes it in an <code>X-A2A-Notification-Token</code> header). <code>authentication</code> <code>AuthenticationInfo</code> | <code>null</code> No Authentication details the A2A Server must use when calling the <code>url</code>. The client's webhook (receiver) defines these requirements."},{"location":"specification/#69-authenticationinfo-object-for-push-notifications","title":"6.9. <code>AuthenticationInfo</code> Object (for Push Notifications)","text":"<p>A generic structure for specifying authentication requirements, typically used within <code>PushNotificationConfig</code> to describe how the A2A Server should authenticate to the client's webhook.</p> <pre><code>interface AuthenticationInfo {\n  // Array of authentication scheme names the caller (i.e., the A2A Server, in the context of push notifications)\n  // must use when sending the request to the webhook URL (e.g., \"Bearer\" for an OAuth token, \"ApiKey\" for a pre-shared key, \"Basic\").\n  // Standard names SHOULD be used.\n  schemes: string[];\n  // Optional field for providing static credentials or scheme-specific information\n  // that the A2A Server needs to use.\n  // Examples:\n  // - For \"ApiKey\": A JSON string like `{\"in\": \"header\", \"name\": \"X-Client-Webhook-Key\", \"value\": \"actual_api_key_value\"}`.\n  // - For \"Bearer\": If the A2A Server is expected to use a specific pre-issued token, it could be provided here. More commonly, the server would obtain its own token using OAuth client credentials flow if this field specifies an OAuth scheme.\n  // **CRITICAL**: Use with extreme caution if this field contains secrets. This configuration is sent from client to server.\n  // Prefer mechanisms where the server fetches its own credentials dynamically (e.g., OAuth client credentials flow with a pre-configured client ID/secret on the server side for the webhook's audience)\n  // rather than having the client provide secrets to the server.\n  // If this field *must* carry a secret, the A2A communication channel itself must be exceptionally secure, and both client and server must handle this data with care.\n  credentials?: string | null; // E.g., A JSON string parsable by the server.\n}\n</code></pre> Field Name Type Required Description <code>schemes</code> <code>string[]</code> Yes Array of auth scheme names the A2A Server must use when calling the client's webhook (e.g., \"Bearer\", \"ApiKey\"). <code>credentials</code> <code>string</code> | <code>null</code> No Optional static credentials or scheme-specific configuration info. Handle with EXTREME CAUTION if secrets are involved. Prefer server-side dynamic credential fetching where possible."},{"location":"specification/#610-taskpushnotificationconfig-object","title":"6.10. <code>TaskPushNotificationConfig</code> Object","text":"<p>Used as the <code>params</code> object for the <code>tasks/pushNotification/set</code> method and as the <code>result</code> object for the <code>tasks/pushNotification/get</code> method.</p> <pre><code>interface TaskPushNotificationConfig {\n  // The ID of the task for which push notification settings are being configured or retrieved.\n  id: string;\n  // The push notification configuration details.\n  // When used as params for `set`, this provides the configuration to apply.\n  // When used as result for `get`, this reflects the currently active configuration (server MAY omit secrets).\n  // If `null` when setting, it might indicate clearing existing configuration (server-dependent).\n  pushNotificationConfig: PushNotificationConfig | null;\n}\n</code></pre> Field Name Type Required Description <code>id</code> <code>string</code> Yes The ID of the task to configure push notifications for, or retrieve configuration from. <code>pushNotificationConfig</code> <code>PushNotificationConfig</code> | <code>null</code> Yes The push notification configuration. For <code>set</code>, the desired config. For <code>get</code>, the current config (secrets MAY be omitted by server). <code>null</code> might clear config on <code>set</code>."},{"location":"specification/#611-json-rpc-structures","title":"6.11. JSON-RPC Structures","text":"<p>A2A adheres to the standard JSON-RPC 2.0 structures for requests and responses.</p>"},{"location":"specification/#6111-jsonrpcrequest-object","title":"6.11.1. <code>JSONRPCRequest</code> Object","text":"<p>All A2A method calls are encapsulated in a JSON-RPC Request object.</p> <ul> <li><code>jsonrpc</code>: A String specifying the version of the JSON-RPC protocol. MUST be exactly <code>\"2.0\"</code>.</li> <li><code>method</code>: A String containing the name of the method to be invoked (e.g., <code>\"tasks/send\"</code>, <code>\"tasks/get\"</code>).</li> <li><code>params</code>: A Structured value that holds the parameter values to be used during the invocation of the method. This member MAY be omitted if the method expects no parameters. A2A methods typically use an <code>object</code> for <code>params</code>.</li> <li><code>id</code>: An identifier established by the Client that MUST contain a String, Number, or <code>NULL</code> value if included. If it is not included it is assumed to be a notification. The value SHOULD NOT be <code>NULL</code> for requests expecting a response, and Numbers SHOULD NOT contain fractional parts. The Server MUST reply with the same value in the Response object if included. This member is used to correlate the context between the two objects. A2A methods typically expect a response or stream, so <code>id</code> will usually be present and non-null.</li> </ul>"},{"location":"specification/#6112-jsonrpcresponse-object","title":"6.11.2. <code>JSONRPCResponse</code> Object","text":"<p>Responses from the A2A Server are encapsulated in a JSON-RPC Response object.</p> <ul> <li><code>jsonrpc</code>: A String specifying the version of the JSON-RPC protocol. MUST be exactly <code>\"2.0\"</code>.</li> <li><code>id</code>: This member is REQUIRED. It MUST be the same as the value of the <code>id</code> member in the Request Object. If there was an error in detecting the <code>id</code> in the Request object (e.g. Parse error/Invalid Request), it MUST be <code>null</code>.</li> <li>EITHER <code>result</code>: This member is REQUIRED on success. This member MUST NOT exist if there was an error invoking the method. The value of this member is determined by the method invoked on the Server.</li> <li>OR <code>error</code>: This member is REQUIRED on failure. This member MUST NOT exist if there was no error triggered during invocation. The value of this member MUST be an <code>JSONRPCError</code> object.</li> <li>The members <code>result</code> and <code>error</code> are mutually exclusive: one MUST be present, and the other MUST NOT.</li> </ul>"},{"location":"specification/#612-jsonrpcerror-object","title":"6.12. <code>JSONRPCError</code> Object","text":"<p>When a JSON-RPC call encounters an error, the Response Object will contain an <code>error</code> member with a value of this structure.</p> <pre><code>interface JSONRPCError {\n  // A Number that indicates the error type that occurred.\n  // This MUST be an integer.\n  code: number;\n  // A String providing a short description of the error.\n  // The message SHOULD be limited to a concise single sentence.\n  message: string;\n  // A Primitive or Structured value that contains additional information about the error.\n  // This may be omitted. The value of this member is defined by the Server (e.g. detailed error codes,\n  // debugging information).\n  data?: any;\n}\n</code></pre> Field Name Type Required Description <code>code</code> <code>integer</code> Yes Integer error code. See Section 8 (Error Handling) for standard and A2A-specific codes. <code>message</code> <code>string</code> Yes Short, human-readable summary of the error. <code>data</code> <code>any</code> | <code>null</code> No Optional additional structured information about the error."},{"location":"specification/#7-protocol-rpc-methods","title":"7. Protocol RPC Methods","text":"<p>All A2A RPC methods are invoked by the A2A Client by sending an HTTP POST request to the A2A Server's <code>url</code> (as specified in its <code>AgentCard</code>). The body of the HTTP POST request MUST be a <code>JSONRPCRequest</code> object, and the <code>Content-Type</code> header MUST be <code>application/json</code>.</p> <p>The A2A Server's HTTP response body MUST be a <code>JSONRPCResponse</code> object (or, for streaming methods, an SSE stream where each event's data is a <code>JSONRPCResponse</code>). The <code>Content-Type</code> for JSON-RPC responses is <code>application/json</code>. For SSE streams, it is <code>text/event-stream</code>.</p>"},{"location":"specification/#71-taskssend","title":"7.1. <code>tasks/send</code>","text":"<p>Sends a message to an agent to initiate a new task or to continue an existing one. This method is suitable for synchronous request/response interactions or when client-side polling (using <code>tasks/get</code>) is acceptable for monitoring longer-running tasks.</p> <ul> <li>Request <code>params</code> type: <code>TaskSendParams</code></li> <li>Response <code>result</code> type (on success): <code>Task</code> (The current or final state of the task after processing the message).</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code>.</li> </ul>"},{"location":"specification/#711-tasksendparams-object","title":"7.1.1. <code>TaskSendParams</code> Object","text":"<pre><code>interface TaskSendParams {\n  // The ID for the task.\n  // - If this is the first message for a new task, the client generates this ID.\n  // - If this message continues an existing task (e.g., providing more input after an `input-required` state),\n  //   this ID MUST match the ID of the existing task.\n  id: string;\n  // Optional client-generated session ID to group this task with others.\n  sessionId?: string | null;\n  // The message to send to the agent. The `role` within this message is typically \"user\".\n  message: Message;\n  // Optional: If initiating a new task, the client MAY include push notification configuration.\n  // If provided for an existing task, server behavior (e.g., update config, ignore) is server-dependent.\n  // Requires `AgentCard.capabilities.pushNotifications: true`.\n  pushNotification?: PushNotificationConfig | null;\n  // Optional: If a positive integer `N` is provided, the server SHOULD include the last `N` messages\n  // (chronologically) of the task's history in the `Task.history` field of the response.\n  // If `0`, `null`, or omitted, no history is explicitly requested (server MAY still include some by default).\n  historyLength?: number | null;\n  // Arbitrary metadata for this specific `tasks/send` request.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Description <code>id</code> <code>string</code> Yes Task ID. If new, the server SHOULD create the task. If existing, this message continues the task. <code>sessionId</code> <code>string</code> | <code>null</code> No Optional client-generated session ID. <code>message</code> <code>Message</code> Yes The message content to send. <code>Message.role</code> is typically <code>\"user\"</code>. <code>pushNotification</code> <code>PushNotificationConfig</code> | <code>null</code> No Optional: sets push notification configuration for the task (usually on the first send). Requires server capability. <code>historyLength</code> <code>integer</code> | <code>null</code> No If positive, requests the server to include up to <code>N</code> recent messages in <code>Task.history</code>. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Request-specific metadata."},{"location":"specification/#72-taskssendsubscribe","title":"7.2. <code>tasks/sendSubscribe</code>","text":"<p>Sends a message to an agent to initiate/continue a task AND subscribes the client to real-time updates for that task via Server-Sent Events (SSE). This method requires the server to have <code>AgentCard.capabilities.streaming: true</code>.</p> <ul> <li>Request <code>params</code> type: <code>TaskSendParams</code> (same as <code>tasks/send</code>).</li> <li>Response (on successful subscription):<ul> <li>HTTP Status: <code>200 OK</code>.</li> <li>HTTP <code>Content-Type</code>: <code>text/event-stream</code>.</li> <li>HTTP Body: A stream of Server-Sent Events. Each SSE <code>data</code> field contains a <code>SendTaskStreamingResponse</code> JSON object.</li> </ul> </li> <li>Response (on initial subscription failure):<ul> <li>Standard HTTP error code (e.g., 4xx, 5xx).</li> <li>The HTTP body MAY contain a standard <code>JSONRPCResponse</code> with an <code>error</code> object detailing the failure.</li> </ul> </li> </ul>"},{"location":"specification/#721-sendtaskstreamingresponse-object","title":"7.2.1. <code>SendTaskStreamingResponse</code> Object","text":"<p>This is the structure of the JSON object found in the <code>data</code> field of each Server-Sent Event sent by the server for a <code>tasks/sendSubscribe</code> or <code>tasks/resubscribe</code> stream. It's a <code>JSONRPCResponse</code> where the <code>result</code> is one of the event types.</p> <pre><code>interface SendTaskStreamingResponse extends JSONRPCResponse {\n  // The `id` MUST match the `id` from the originating `tasks/sendSubscribe` (or `tasks/resubscribe`)\n  // JSON-RPC request that established this SSE stream.\n  id: string | number; // Overrides JSONRPCResponse 'id' type for clarity and to emphasize it matches the original request.\n  // The `result` field contains the actual event payload for this streaming update.\n  // It will be either a TaskStatusUpdateEvent or a TaskArtifactUpdateEvent.\n  result: TaskStatusUpdateEvent | TaskArtifactUpdateEvent;\n  // For streaming events, `error` is typically `null` or absent.\n  // If a fatal error occurs that terminates the stream, the server MAY send a final\n  // SSE event with this `error` field populated before closing the connection.\n  error?: JSONRPCError | null;\n}\n</code></pre> Field Name Type Required Description <code>jsonrpc</code> <code>\"2.0\"</code> (literal) Yes JSON-RPC version string. <code>id</code> <code>string</code> | <code>number</code> Yes Matches the <code>id</code> from the originating <code>tasks/sendSubscribe</code> or <code>tasks/resubscribe</code> request. <code>result</code> Either <code>TaskStatusUpdateEvent</code> OR <code>TaskArtifactUpdateEvent</code> Yes The event payload: either a status update or an artifact update. <code>error</code> <code>JSONRPCError</code> | <code>null</code> No Typically <code>null</code> or absent for stream events. If a fatal stream error occurs, this MAY be populated in the final SSE message before the stream closes."},{"location":"specification/#722-taskstatusupdateevent-object","title":"7.2.2. <code>TaskStatusUpdateEvent</code> Object","text":"<p>Carries information about a change in the task's status during streaming. This is one of the possible <code>result</code> types in a <code>SendTaskStreamingResponse</code>.</p> <pre><code>interface TaskStatusUpdateEvent {\n  // The ID of the task being updated. This MUST match the `TaskSendParams.id`\n  // from the `tasks/sendSubscribe` request that initiated this stream.\n  id: string;\n  // The new status object for the task.\n  status: TaskStatus;\n  // If `true`, this `TaskStatusUpdateEvent` signifies the terminal status update for the current\n  // `tasks/sendSubscribe` interaction cycle. This means the task has reached a state like\n  // `completed`, `failed`, `canceled`, or `input-required`, and the server does not expect to send\n  // more updates for *this specific* `sendSubscribe` request. The server typically closes the SSE\n  // connection after sending an event with `final: true`.\n  // Default: `false` if omitted.\n  final?: boolean;\n  // Arbitrary metadata for this specific status update event.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Default Description <code>id</code> <code>string</code> Yes Task ID being updated, matching the original request's task ID. <code>status</code> <code>TaskStatus</code> Yes The new <code>TaskStatus</code> object. <code>final</code> <code>boolean</code> No <code>false</code> If <code>true</code>, indicates this is the terminal status update for the current stream cycle. The server typically closes the SSE connection after this. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No <code>null</code> Event-specific metadata."},{"location":"specification/#723-taskartifactupdateevent-object","title":"7.2.3. <code>TaskArtifactUpdateEvent</code> Object","text":"<p>Carries a new or updated artifact (or a chunk of an artifact) generated by the task during streaming. This is one of the possible <code>result</code> types in a <code>SendTaskStreamingResponse</code>.</p> <pre><code>interface TaskArtifactUpdateEvent {\n  // The ID of the task that generated this artifact. This MUST match the `TaskSendParams.id`\n  // from the `tasks/sendSubscribe` request that initiated this stream.\n  id: string;\n  // The artifact data. This could be a complete artifact or an incremental chunk.\n  // The client uses `artifact.index`, `artifact.append`, and `artifact.lastChunk`\n  // to correctly assemble or update the artifact on its side.\n  artifact: Artifact;\n  // Arbitrary metadata for this specific artifact update event.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> <p>| Field Name | Type                              | Required | Description                                                                                                                                                          | | :--------- | :-------------------------------- | :------- | :------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------ | | <code>id</code>       | <code>string</code>                          | Yes      | Task ID that generated the artifact, matching the original request's task ID.                                                                                        | | <code>artifact</code> | <code>Artifact</code> | Yes      | The <code>Artifact</code> data. Could be a complete artifact or an incremental chunk. Use <code>index</code>, <code>append</code>, and <code>lastChunk</code> fields within <code>Artifact</code> for client-side assembly. | | <code>metadata</code> | <code>Record&lt;string, any&gt;</code> | <code>null</code>   | No       | <code>null</code>                                                                                                                                                               | Event-specific metadata. |</p>"},{"location":"specification/#73-tasksget","title":"7.3. <code>tasks/get</code>","text":"<p>Retrieves the current state (including status, artifacts, and optionally history) of a previously initiated task. This is typically used for polling the status of a task initiated with <code>tasks/send</code>, or for fetching the final state of a task after being notified via a push notification or after an SSE stream has ended.</p> <ul> <li>Request <code>params</code> type: <code>TaskQueryParams</code></li> <li>Response <code>result</code> type (on success): <code>Task</code> (A snapshot of the task's current state).</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., if the task ID is not found, see <code>TaskNotFoundError</code>).</li> </ul>"},{"location":"specification/#731-taskqueryparams-object","title":"7.3.1. <code>TaskQueryParams</code> Object","text":"<pre><code>interface TaskQueryParams {\n  // The ID of the task to retrieve.\n  id: string;\n  // Optional: If a positive integer `N` is provided, the server SHOULD include the last `N` messages\n  // (chronologically) of the task's history in the `Task.history` field of the response.\n  // If `0`, `null`, or omitted, no history is explicitly requested.\n  historyLength?: number | null;\n  // Arbitrary metadata for this specific `tasks/get` request.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Description <code>id</code> <code>string</code> Yes The ID of the task whose current state is to be retrieved. <code>historyLength</code> <code>integer</code> | <code>null</code> No If positive, requests the server to include up to <code>N</code> recent messages in <code>Task.history</code>. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Request-specific metadata."},{"location":"specification/#74-taskscancel","title":"7.4. <code>tasks/cancel</code>","text":"<p>Requests the cancellation of an ongoing task. The server will attempt to cancel the task, but success is not guaranteed (e.g., the task might have already completed or failed, or cancellation might not be supported at its current stage).</p> <ul> <li>Request <code>params</code> type: <code>TaskIdParams</code></li> <li>Response <code>result</code> type (on success): <code>Task</code> (The state of the task after the cancellation attempt. Ideally, <code>Task.status.state</code> will be <code>\"canceled\"</code> if successful).</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>TaskNotFoundError</code>, <code>TaskNotCancelableError</code>).</li> </ul>"},{"location":"specification/#741-taskidparams-object-for-taskscancel-and-taskspushnotificationget","title":"7.4.1. <code>TaskIdParams</code> Object (for <code>tasks/cancel</code> and <code>tasks/pushNotification/get</code>)","text":"<p>A simple object containing just the task ID and optional metadata.</p> <pre><code>interface TaskIdParams {\n  // The ID of the task to which the operation applies (e.g., cancel, get push notification config).\n  id: string;\n  // Arbitrary metadata for this specific request.\n  metadata?: Record&lt;string, any&gt; | null;\n}\n</code></pre> Field Name Type Required Description <code>id</code> <code>string</code> Yes The ID of the task. <code>metadata</code> <code>Record&lt;string, any&gt;</code> | <code>null</code> No Request-specific metadata."},{"location":"specification/#75-taskspushnotificationset","title":"7.5. <code>tasks/pushNotification/set</code>","text":"<p>Sets or updates the push notification configuration for a specified task. This allows the client to tell the server where and how to send asynchronous updates for the task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> <ul> <li>Request <code>params</code> type: <code>TaskPushNotificationConfig</code></li> <li>Response <code>result</code> type (on success): <code>TaskPushNotificationConfig</code> (Confirms the configuration that was set. The server MAY omit or mask any sensitive details like secrets from the <code>authentication.credentials</code> field in the response).</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>PushNotificationNotSupportedError</code>, <code>TaskNotFoundError</code>, errors related to invalid <code>PushNotificationConfig</code>).</li> </ul>"},{"location":"specification/#76-taskspushnotificationget","title":"7.6. <code>tasks/pushNotification/get</code>","text":"<p>Retrieves the current push notification configuration for a specified task. Requires the server to have <code>AgentCard.capabilities.pushNotifications: true</code>.</p> <ul> <li>Request <code>params</code> type: <code>TaskIdParams</code></li> <li>Response <code>result</code> type (on success): <code>TaskPushNotificationConfig</code> (The current push notification configuration for the task. If no configuration is set, <code>pushNotificationConfig</code> field might be <code>null</code> or an empty object. The server MAY omit or mask any sensitive details from the <code>authentication.credentials</code> field).</li> <li>Response <code>error</code> type (on failure): <code>JSONRPCError</code> (e.g., <code>PushNotificationNotSupportedError</code>, <code>TaskNotFoundError</code>).</li> </ul>"},{"location":"specification/#77-tasksresubscribe","title":"7.7. <code>tasks/resubscribe</code>","text":"<p>Allows a client to reconnect to an SSE stream for an ongoing task after a previous connection (from <code>tasks/sendSubscribe</code> or an earlier <code>tasks/resubscribe</code>) was interrupted. Requires the server to have <code>AgentCard.capabilities.streaming: true</code>.</p> <p>The purpose is to resume receiving subsequent updates. The server's behavior regarding events missed during the disconnection period (e.g., whether it attempts to backfill some missed events or only sends new ones from the point of resubscription) is implementation-dependent and not strictly defined by this specification.</p> <ul> <li>Request <code>params</code> type: <code>TaskQueryParams</code> (The <code>historyLength</code> parameter is typically ignored for resubscription, as the focus is on future events, but it's included for structural consistency).</li> <li>Response (on successful resubscription):<ul> <li>HTTP Status: <code>200 OK</code>.</li> <li>HTTP <code>Content-Type</code>: <code>text/event-stream</code>.</li> <li>HTTP Body: A stream of Server-Sent Events, identical in format to <code>tasks/sendSubscribe</code>, carrying subsequent <code>SendTaskStreamingResponse</code> events for the task.</li> </ul> </li> <li>Response (on resubscription failure):<ul> <li>Standard HTTP error code (e.g., 4xx, 5xx).</li> <li>The HTTP body MAY contain a standard <code>JSONRPCResponse</code> with an <code>error</code> object. Failures can occur if the task is no longer active, doesn't exist, or streaming is not supported/enabled for it.</li> </ul> </li> </ul>"},{"location":"specification/#8-error-handling","title":"8. Error Handling","text":"<p>A2A uses standard JSON-RPC 2.0 error codes and structure for reporting errors. Errors are returned in the <code>error</code> member of the <code>JSONRPCResponse</code> object. See <code>JSONRPCError</code> Object definition.</p>"},{"location":"specification/#81-standard-json-rpc-errors","title":"8.1. Standard JSON-RPC Errors","text":"<p>These are standard codes defined by the JSON-RPC 2.0 specification.</p> Code JSON-RPC Spec Meaning Typical A2A <code>message</code> Description <code>-32700</code> Parse error Invalid JSON payload Server received JSON that was not well-formed. <code>-32600</code> Invalid Request Invalid JSON-RPC Request The JSON payload was valid JSON, but not a valid JSON-RPC Request object. <code>-32601</code> Method not found Method not found The requested A2A RPC <code>method</code> (e.g., <code>\"tasks/foo\"</code>) does not exist or is not supported. <code>-32602</code> Invalid params Invalid method parameters The <code>params</code> provided for the method are invalid (e.g., wrong type, missing required field). <code>-32603</code> Internal error Internal server error An unexpected error occurred on the server during processing. <code>-32000</code> to <code>-32099</code> Server error (Server-defined) Reserved for implementation-defined server-errors. A2A-specific errors use this range."},{"location":"specification/#82-a2a-specific-errors","title":"8.2. A2A-Specific Errors","text":"<p>These are custom error codes defined within the JSON-RPC server error range (<code>-32000</code> to <code>-32099</code>) to provide more specific feedback about A2A-related issues. Servers SHOULD use these codes where applicable.</p> Code Error Name (Conceptual) Typical <code>message</code> string Description <code>-32001</code> <code>TaskNotFoundError</code> Task not found The specified task <code>id</code> does not correspond to an existing or active task. It might be invalid, expired, or already completed and purged. <code>-32002</code> <code>TaskNotCancelableError</code> Task cannot be canceled An attempt was made to cancel a task that is not in a cancelable state (e.g., it has already reached a terminal state like <code>completed</code>, <code>failed</code>, or <code>canceled</code>). <code>-32003</code> <code>PushNotificationNotSupportedError</code> Push Notification is not supported Client attempted to use push notification features (e.g., <code>tasks/pushNotification/set</code>) but the server agent does not support them (i.e., <code>AgentCard.capabilities.pushNotifications</code> is <code>false</code>). <code>-32004</code> <code>OperationNotSupportedError</code> This operation is not supported The requested operation or a specific aspect of it (perhaps implied by parameters) is not supported by this server agent implementation. Broader than just method not found. <code>-32005</code> <code>ContentTypeNotSupportedError</code> Incompatible content types A MIME type provided in the request's <code>message.parts</code> (or implied for an artifact) is not supported by the agent or the specific skill being invoked. <code>-32006</code> <code>StreamingNotSupportedError</code> Streaming is not supported Client attempted <code>tasks/sendSubscribe</code> or <code>tasks/resubscribe</code> but the server agent does not support streaming (i.e., <code>AgentCard.capabilities.streaming</code> is <code>false</code>). <code>-32007</code> <code>AuthenticationRequiredError</code> Authentication required The request lacks necessary authentication credentials, or the provided credentials are invalid or insufficient. This often accompanies an HTTP <code>401 Unauthorized</code> status. <code>-32008</code> <code>AuthorizationFailedError</code> Authorization failed The authenticated identity is not authorized to perform the requested action or access the specified resource (e.g., a specific task or skill). This often accompanies an HTTP <code>403 Forbidden</code> status. <code>-32009</code> <code>InvalidTaskStateError</code> Invalid task state for operation The operation is not valid for the task's current <code>TaskState</code> (e.g., trying to send a message to a task that is already <code>completed</code>). <code>-32010</code> <code>RateLimitExceededError</code> Rate limit exceeded The client has made too many requests in a given amount of time. <code>-32011</code> <code>ResourceUnavailableError</code> A required resource is unavailable The server cannot complete the request because a necessary downstream resource or service is temporarily or permanently unavailable. <p>Servers MAY define additional error codes within the <code>-32000</code> to <code>-32099</code> range for more specific scenarios not covered above, but they SHOULD document these clearly. The <code>data</code> field of the <code>JSONRPCError</code> object can be used to provide more structured details for any error.</p>"},{"location":"specification/#9-common-workflows-examples","title":"9. Common Workflows &amp; Examples","text":"<p>This section provides illustrative JSON examples of common A2A interactions. Timestamps, session IDs, and request/response IDs are for demonstration purposes. For brevity, some optional fields might be omitted if not central to the example.</p>"},{"location":"specification/#91-basic-task-execution-synchronous-polling-style","title":"9.1. Basic Task Execution (Synchronous / Polling Style)","text":"<p>Scenario: Client asks a simple question, and the agent responds quickly.</p> <ol> <li>Client sends a message using <code>tasks/send</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-abc-123\",\n    \"sessionId\": \"session-xyz-789\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"What is the capital of France?\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the request and responds (task completes quickly):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-001\",\n  \"result\": {\n    \"id\": \"task-abc-123\",\n    \"sessionId\": \"session-xyz-789\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"The capital of France is Paris.\"\n          }\n        ]\n      },\n      \"timestamp\": \"2024-03-15T10:00:05Z\"\n    },\n    \"artifacts\": [\n      {\n        \"name\": \"Answer\",\n        \"index\": 0,\n        \"parts\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"The capital of France is Paris.\"\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>If the task were longer-running, the server might initially respond with <code>status.state: \"working\"</code>. The client would then periodically call <code>tasks/get</code> with <code>params: {\"id\": \"task-abc-123\"}</code> until the task reaches a terminal state.</p>"},{"location":"specification/#92-streaming-task-execution-sse","title":"9.2. Streaming Task Execution (SSE)","text":"<p>Scenario: Client asks the agent to write a short story, and the agent streams the story incrementally.</p> <ol> <li>Client sends a message and subscribes using <code>tasks/sendSubscribe</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-002\",\n  \"method\": \"tasks/sendSubscribe\",\n  \"params\": {\n    \"id\": \"task-story-456\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"Write a very short story about a curious robot exploring Mars.\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <ol> <li>Server responds with HTTP 200 OK, <code>Content-Type: text/event-stream</code>, and starts sending SSE events:</li> </ol> <p>Event 1: Task status update - working</p> <pre><code>id: sse-evt-101\nevent: message\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-002\",\"result\":{\"id\":\"task-story-456\",\"status\":{\"state\":\"working\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Okay, I'm starting to write that story for you...\"}]},\"timestamp\":\"2024-03-15T10:05:01Z\"},\"final\":false}}\n</code></pre> <p>Event 2: Artifact update - first chunk of the story</p> <pre><code>id: sse-evt-102\nevent: message\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-002\",\"result\":{\"id\":\"task-story-456\",\"artifact\":{\"name\":\"MarsStory.txt\",\"index\":0,\"parts\":[{\"type\":\"text\",\"text\":\"Unit 734, a small rover with oversized optical sensors, trundled across the ochre plains. \"}]}}}\n</code></pre> <p>Event 3: Artifact update - second chunk (appended)</p> <pre><code>id: sse-evt-103\nevent: message\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-002\",\"result\":{\"id\":\"task-story-456\",\"artifact\":{\"name\":\"MarsStory.txt\",\"index\":0,\"append\":true,\"parts\":[{\"type\":\"text\",\"text\":\"Its mission: to find the source of a peculiar signal. \"}]}}}\n</code></pre> <p>Event 4: Artifact update - final chunk</p> <pre><code>id: sse-evt-104\nevent: message\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-002\",\"result\":{\"id\":\"task-story-456\",\"artifact\":{\"name\":\"MarsStory.txt\",\"index\":0,\"append\":true,\"lastChunk\":true,\"parts\":[{\"type\":\"text\",\"text\":\"Olympus Mons loomed, a silent giant, as Unit 734 beeped excitedly.\"}]}}}\n</code></pre> <p>Event 5: Task status update - completed</p> <pre><code>id: sse-evt-105\nevent: message\ndata: {\"jsonrpc\":\"2.0\",\"id\":\"req-002\",\"result\":{\"id\":\"task-story-456\",\"status\":{\"state\":\"completed\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"The story is complete!\"}]},\"timestamp\":\"2024-03-15T10:05:05Z\"},\"final\":true}}\n</code></pre> <p>(Server closes the SSE connection after the <code>final:true</code> event). (Note: SSE <code>id</code> and <code>event</code> fields are part of the SSE protocol itself, distinct from the JSON-RPC <code>id</code> within the <code>data</code> payload).</p>"},{"location":"specification/#93-multi-turn-interaction-input-required","title":"9.3. Multi-Turn Interaction (Input Required)","text":"<p>Scenario: Client wants to book a flight, and the agent needs more information.</p> <ol> <li>Client <code>tasks/send</code> (initial request):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-003\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-flightbook-789\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [{ \"type\": \"text\", \"text\": \"I'd like to book a flight.\" }]\n    }\n  }\n}\n</code></pre> <ol> <li>Server responds, task state is <code>input-required</code>:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-003\",\n  \"result\": {\n    \"id\": \"task-flightbook-789\",\n    \"status\": {\n      \"state\": \"input-required\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"Sure, I can help with that! Where would you like to fly to, and from where? Also, what are your preferred travel dates?\"\n          }\n        ]\n      },\n      \"timestamp\": \"2024-03-15T10:10:00Z\"\n    }\n  }\n}\n</code></pre> <ol> <li>Client <code>tasks/send</code> (providing the requested input, using the same task ID):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-004\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-flightbook-789\" /* Same task ID */,\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"I want to fly from New York (JFK) to London (LHR) around October 10th, returning October 17th.\"\n        }\n      ]\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the new input and responds (e.g., task completed or more input needed):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-004\",\n  \"result\": {\n    \"id\": \"task-flightbook-789\",\n    \"status\": {\n      \"state\": \"completed\",\n      \"message\": {\n        \"role\": \"agent\",\n        \"parts\": [\n          {\n            \"type\": \"text\",\n            \"text\": \"Okay, I've found a flight for you. Confirmation XYZ123. Details are in the artifact.\"\n          }\n        ]\n      },\n      \"timestamp\": \"2024-03-15T10:11:00Z\"\n    },\n    \"artifacts\": [\n      {\n        \"name\": \"FlightItinerary.json\",\n        \"parts\": [\n          {\n            \"type\": \"data\",\n            \"data\": {\n              \"confirmationId\": \"XYZ123\",\n              \"from\": \"JFK\",\n              \"to\": \"LHR\",\n              \"departure\": \"2024-10-10T18:00:00Z\",\n              \"arrival\": \"2024-10-11T06:00:00Z\",\n              \"returnDeparture\": \"...\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/#94-push-notification-setup-and-usage","title":"9.4. Push Notification Setup and Usage","text":"<p>Scenario: Client requests a long-running report generation and wants to be notified via webhook when it's done.</p> <ol> <li>Client <code>tasks/send</code> with <code>pushNotification</code> config:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-005\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-reportgen-aaa\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"Generate the Q1 sales report. This usually takes a while. Notify me when it's ready.\"\n        }\n      ]\n    },\n    \"pushNotification\": {\n      \"url\": \"https://client.example.com/webhook/a2a-notifications\",\n      \"token\": \"secure-client-token-for-task-aaa\",\n      \"authentication\": {\n        \"schemes\": [\"Bearer\"]\n        // Assuming server knows how to get a Bearer token for this webhook audience,\n        // or this implies the webhook is public/uses the 'token' for auth.\n        // 'credentials' could provide more specifics if needed by the server.\n      }\n    }\n  }\n}\n</code></pre> <ol> <li>Server acknowledges the task (e.g., status <code>submitted</code> or <code>working</code>):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-005\",\n  \"result\": {\n    \"id\": \"task-reportgen-aaa\",\n    \"status\": { \"state\": \"submitted\", \"timestamp\": \"2024-03-15T11:00:00Z\" }\n    // ... other fields ...\n  }\n}\n</code></pre> <ol> <li> <p>(Later) A2A Server completes the task and POSTs a notification to <code>https://client.example.com/webhook/a2a-notifications</code>:</p> </li> <li> <p>HTTP Headers might include:</p> <ul> <li><code>Authorization: Bearer &lt;server_jwt_for_webhook_audience&gt;</code> (if server authenticates to webhook)</li> <li><code>Content-Type: application/json</code></li> <li><code>X-A2A-Notification-Token: secure-client-token-for-task-aaa</code></li> </ul> </li> <li>HTTP Body (example, actual payload is server-defined, but SHOULD include <code>taskId</code> and <code>status</code>):</li> </ol> <pre><code>{\n  \"eventType\": \"taskUpdate\",\n  \"taskId\": \"task-reportgen-aaa\",\n  \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T18:30:00Z\" },\n  \"summary\": \"Q1 sales report generated successfully.\"\n  // Server MAY include more details or a link to fetch the full task.\n}\n</code></pre> <ol> <li> <p>Client's Webhook Service:</p> </li> <li> <p>Receives the POST.</p> </li> <li>Validates the <code>Authorization</code> header (if applicable).</li> <li>Validates the <code>X-A2A-Notification-Token</code>.</li> <li> <p>Internally processes the notification (e.g., updates application state, notifies end-user).</p> </li> <li> <p>Client (optionally, upon receiving and validating the push notification) calls <code>tasks/get</code> to retrieve full artifacts:</p> </li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-006\",\n  \"method\": \"tasks/get\",\n  \"params\": { \"id\": \"task-reportgen-aaa\" }\n}\n</code></pre> <p>(Server responds with the full <code>Task</code> object, including the generated report in <code>Task.artifacts</code>).</p>"},{"location":"specification/#95-file-exchange-upload-and-download","title":"9.5. File Exchange (Upload and Download)","text":"<p>Scenario: Client sends an image for analysis, and the agent returns a modified image.</p> <ol> <li>Client <code>tasks/send</code> with a <code>FilePart</code> (uploading image bytes):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-007\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-imageanalysis-bbb\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"Analyze this image and highlight any faces.\"\n        },\n        {\n          \"type\": \"file\",\n          \"file\": {\n            \"name\": \"input_image.png\",\n            \"mimeType\": \"image/png\",\n            \"bytes\": \"iVBORw0KGgoAAAANSUhEUgAAAAUA...\" // Base64 encoded image data\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <ol> <li>Server processes the image and responds with a <code>FilePart</code> in an artifact (e.g., providing a URI to the modified image):</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-007\",\n  \"result\": {\n    \"id\": \"task-imageanalysis-bbb\",\n    \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T12:05:00Z\" },\n    \"artifacts\": [\n      {\n        \"name\": \"processed_image_with_faces.png\",\n        \"index\": 0,\n        \"parts\": [\n          {\n            \"type\": \"file\",\n            \"file\": {\n              \"name\": \"output.png\",\n              \"mimeType\": \"image/png\",\n              // Server might provide a URI to a temporary storage location\n              \"uri\": \"https://storage.example.com/processed/task-bbb/output.png?token=xyz\"\n              // Or, alternatively, it could return bytes directly:\n              // \"bytes\": \"ASEDGhw0KGgoAAAANSUhEUgAA...\"\n            }\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre>"},{"location":"specification/#96-structured-data-exchange-requesting-and-providing-json","title":"9.6. Structured Data Exchange (Requesting and Providing JSON)","text":"<p>Scenario: Client asks for a list of open support tickets in a specific JSON format.</p> <ol> <li>Client <code>tasks/send</code>, <code>Part.metadata</code> hints at desired output schema/MIME type: (Note: A2A doesn't formally standardize schema negotiation in v0.1.0, but <code>metadata</code> can be used for such hints by convention between client/server).</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-008\",\n  \"method\": \"tasks/send\",\n  \"params\": {\n    \"id\": \"task-gettickets-ccc\",\n    \"message\": {\n      \"role\": \"user\",\n      \"parts\": [\n        {\n          \"type\": \"text\",\n          \"text\": \"List my open IT support tickets created in the last week.\",\n          \"metadata\": {\n            \"desiredOutputMimeType\": \"application/json\",\n            \"desiredOutputSchemaRef\": \"https://schemas.example.com/supportTicketList_v1.json\"\n            // This metadata is a convention, not strictly enforced by A2A spec\n          }\n        }\n      ]\n    }\n  }\n}\n</code></pre> <ol> <li>Server responds with a <code>DataPart</code> containing the structured JSON data:</li> </ol> <pre><code>{\n  \"jsonrpc\": \"2.0\",\n  \"id\": \"req-008\",\n  \"result\": {\n    \"id\": \"task-gettickets-ccc\",\n    \"status\": { \"state\": \"completed\", \"timestamp\": \"2024-03-15T12:15:00Z\" },\n    \"artifacts\": [\n      {\n        \"name\": \"open_support_tickets.json\",\n        \"index\": 0,\n        \"parts\": [\n          {\n            \"type\": \"data\",\n            \"metadata\": {\n              \"mimeType\": \"application/json\", // Explicitly state MIME type\n              \"schemaRef\": \"https://schemas.example.com/supportTicketList_v1.json\" // Confirming schema\n            },\n            \"data\": [\n              {\n                \"ticketId\": \"IT00123\",\n                \"summary\": \"Cannot connect to VPN\",\n                \"status\": \"Open\",\n                \"createdDate\": \"2024-03-14T09:30:00Z\"\n              },\n              {\n                \"ticketId\": \"IT00125\",\n                \"summary\": \"Printer not working on 3rd floor\",\n                \"status\": \"In Progress\",\n                \"createdDate\": \"2024-03-13T15:00:00Z\"\n              }\n            ]\n          }\n        ]\n      }\n    ]\n  }\n}\n</code></pre> <p>These examples illustrate the flexibility of A2A in handling various interaction patterns and data types. Implementers should refer to the detailed object definitions for all fields and constraints.</p>"},{"location":"specification/#10-appendices","title":"10. Appendices","text":""},{"location":"specification/#101-relationship-to-mcp-model-context-protocol","title":"10.1. Relationship to MCP (Model Context Protocol)","text":"<p>A2A and MCP are complementary protocols designed for different aspects of agentic systems:</p> <ul> <li>Model Context Protocol (MCP): Focuses on standardizing how AI models and agents connect to and interact with tools, APIs, data sources, and other external resources. It defines structured ways to describe tool capabilities (like function calling in LLMs), pass inputs, and receive structured outputs. Think of MCP as the \"how-to\" for an agent to use a specific capability or access a resource.</li> <li>Agent2Agent Protocol (A2A): Focuses on standardizing how independent, often opaque, AI agents communicate and collaborate with each other as peers. A2A provides an application-level protocol for agents to discover each other, negotiate interaction modalities, manage shared tasks, and exchange conversational context or complex results. It's about how agents partner or delegate work.</li> </ul> <p>How they work together: An A2A Client agent might request an A2A Server agent to perform a complex task. The Server agent, in turn, might use MCP to interact with several underlying tools, APIs, or data sources to gather information or perform actions necessary to fulfill the A2A task.</p> <p>For a more detailed comparison, see the A2A and MCP guide.</p>"},{"location":"specification/#102-security-considerations-summary","title":"10.2. Security Considerations Summary","text":"<p>Security is a paramount concern in A2A. Key considerations include:</p> <ul> <li>Transport Security: Always use HTTPS with strong TLS configurations in production environments.</li> <li>Authentication:<ul> <li>Handled via standard HTTP mechanisms (e.g., <code>Authorization</code> header with Bearer tokens, API keys).</li> <li>Requirements are declared in the <code>AgentCard</code>.</li> <li>Credentials MUST be obtained out-of-band by the client.</li> <li>A2A Servers MUST authenticate every request.</li> </ul> </li> <li>Authorization:<ul> <li>A server-side responsibility based on the authenticated identity.</li> <li>Implement the principle of least privilege.</li> <li>Can be granular, based on skills, actions, or data.</li> </ul> </li> <li>Push Notification Security:<ul> <li>Webhook URL validation (by the A2A Server sending notifications) is crucial to prevent SSRF.</li> <li>Authentication of the A2A Server to the client's webhook is essential.</li> <li>Authentication of the notification by the client's webhook receiver (verifying it came from the legitimate A2A Server and is relevant) is critical.</li> <li>See the Streaming &amp; Asynchronous Operations guide for detailed push notification security.</li> </ul> </li> <li>Input Validation: Servers MUST rigorously validate all RPC parameters and the content/structure of data in <code>Message</code> and <code>Artifact</code> parts to prevent injection attacks or processing errors.</li> <li>Resource Management: Implement rate limiting, concurrency controls, and resource limits to protect agents from abuse or overload.</li> <li>Data Privacy: Adhere to all applicable privacy regulations for data exchanged in <code>Message</code> and <code>Artifact</code> parts. Minimize sensitive data transfer.</li> </ul> <p>For a comprehensive discussion, refer to the Enterprise-Ready Features guide.</p>"},{"location":"topics/a2a-and-mcp/","title":"A2A and MCP: Complementary Protocols for Agentic Systems","text":""},{"location":"topics/a2a-and-mcp/#a2a-mcp","title":"A2A \u2764\ufe0f MCP","text":"<p>In the landscape of AI agent development, two key types of protocols are emerging to facilitate interoperability: those for connecting agents to tools and resources, and those for enabling agent-to-agent collaboration. The Agent2Agent (A2A) Protocol and the Model Context Protocol (MCP) address these distinct but related needs.</p> <p>TL;DR; Agentic applications need both A2A and MCP. We recommend MCP for tools and A2A for agents.</p>"},{"location":"topics/a2a-and-mcp/#why-different-protocols","title":"Why Different Protocols?","text":"<p>The distinction arises from the nature of what an agent interacts with:</p> <ul> <li> <p>Tools &amp; Resources:</p> <ul> <li>These are typically primitives with well-defined, structured inputs and outputs. They perform specific, often stateless, functions (e.g., a calculator, a database query API, a weather lookup service).</li> <li>Their behavior is generally predictable and transactional.</li> <li>Interaction is often a single request-response cycle.</li> </ul> </li> <li> <p>Agents:</p> <ul> <li>These are more autonomous systems. They can reason, plan, use multiple tools, maintain state over longer interactions, and engage in complex, often multi-turn dialogues to achieve novel or evolving tasks.</li> <li>Their behavior can be emergent and less predictable than a simple tool.</li> <li>Interaction often involves ongoing tasks, context sharing, and negotiation.</li> </ul> </li> </ul> <p>Agentic applications need to leverage both: agents use tools to gather information and perform actions, and agents collaborate with other agents to tackle broader, more complex goals.</p>"},{"location":"topics/a2a-and-mcp/#model-context-protocol-mcp","title":"Model Context Protocol (MCP)","text":"<ul> <li>Focus: MCP standardizes how AI models and agents connect to and interact with tools, APIs, data sources, and other external resources.</li> <li>Mechanism: It defines a structured way to describe tool capabilities (akin to function calling in Large Language Models), pass inputs to them, and receive structured outputs.</li> <li>Use Cases:<ul> <li>Enabling an LLM to call an external API (e.g., fetch current stock prices).</li> <li>Allowing an agent to query a database with specific parameters.</li> <li>Connecting an agent to a set of predefined functions or services.</li> </ul> </li> <li>Ecosystem: MCP aims to create an ecosystem where tool providers can easily expose their services to various AI models and agent frameworks, and agent developers can easily consume these tools in a standardized way.</li> </ul>"},{"location":"topics/a2a-and-mcp/#agent2agent-protocol-a2a","title":"Agent2Agent Protocol (A2A)","text":"<ul> <li>Focus: A2A standardizes how independent, often opaque, AI agents communicate and collaborate with each other as peers.</li> <li>Mechanism: It provides an application-level protocol for agents to:<ul> <li>Discover each other's high-level skills and capabilities (via Agent Cards).</li> <li>Negotiate interaction modalities (text, files, structured data).</li> <li>Manage shared, stateful, and potentially long-running tasks.</li> <li>Exchange conversational context, instructions, and complex, multi-part results.</li> </ul> </li> <li>Use Cases:<ul> <li>A customer service agent delegating a complex billing inquiry to a specialized billing agent, maintaining context of the customer interaction.</li> <li>A travel planning agent coordinating with separate flight, hotel, and activity booking agents, managing a multi-stage booking process.</li> <li>Agents exchanging information and status updates for a collaborative project that evolves over time.</li> </ul> </li> <li>Key Difference from Tool Interaction: A2A allows for more dynamic, stateful, and potentially multi-modal interactions than typically seen with simple tool calls. Agents using A2A communicate as agents (or on behalf of users) rather than just invoking a discrete function.</li> </ul>"},{"location":"topics/a2a-and-mcp/#how-a2a-and-mcp-complement-each-other","title":"How A2A and MCP Complement Each Other","text":"<p>A2A and MCP are not mutually exclusive; they are highly complementary and address different layers of an agentic system's interaction needs.</p> <p></p> <p>An agentic application might use A2A to communicate with other agents, while each agent internally uses MCP to interact with its specific tools and resources.</p>"},{"location":"topics/a2a-and-mcp/#example-scenario-the-auto-repair-shop","title":"Example Scenario: The Auto Repair Shop","text":"<p>Consider an auto repair shop staffed by autonomous AI agent \"mechanics\" who use special-purpose tools (such as vehicle jacks, multimeters, and socket wrenches) to diagnose and repair problems. The workers often have to diagnose and repair problems they have not seen before. The repair process can involve extensive conversations with a customer, research, and working with part suppliers.</p> <ol> <li> <p>Customer Interaction (User-to-Agent via A2A):</p> <ul> <li>A customer (or their primary assistant agent) uses A2A to communicate with the \"Shop Manager\" agent: \"My car is making a rattling noise.\"</li> <li>The Shop Manager agent uses A2A for a multi-turn diagnostic conversation: \"Can you send a video of the noise?\", \"I see some fluid leaking. How long has this been happening?\"</li> </ul> </li> <li> <p>Internal Tool Usage (Agent-to-Tool via MCP):</p> <ul> <li>The Mechanic agent, assigned the task by the Shop Manager, needs to diagnose the issue. It uses MCP to interact with its specialized tools:<ul> <li>MCP call to a \"Vehicle Diagnostic Scanner\" tool: <code>scan_vehicle_for_error_codes(vehicle_id='XYZ123')</code>.</li> <li>MCP call to a \"Repair Manual Database\" tool: <code>get_repair_procedure(error_code='P0300', vehicle_make='Toyota', vehicle_model='Camry')</code>.</li> <li>MCP call to a \"Platform Lift\" tool: <code>raise_platform(height_meters=2)</code>.</li> </ul> </li> </ul> </li> <li> <p>Supplier Interaction (Agent-to-Agent via A2A):</p> <ul> <li>The Mechanic agent determines a specific part is needed. It uses A2A to communicate with a \"Parts Supplier\" agent: \"Do you have part #12345 in stock for a Toyota Camry 2018?\"</li> <li>The Parts Supplier agent, also an A2A-compliant system, responds, potentially leading to an order.</li> </ul> </li> </ol> <p>In this example:</p> <ul> <li>A2A facilitates the higher-level, conversational, and task-oriented interactions between the customer and the shop, and between the shop's agents and external supplier agents.</li> <li>MCP enables the mechanic agent to use its specific, structured tools to perform its diagnostic and repair functions.</li> </ul>"},{"location":"topics/a2a-and-mcp/#representing-a2a-agents-as-mcp-resources","title":"Representing A2A Agents as MCP Resources","text":"<p>It's conceivable that an A2A Server (a remote agent) could also expose some of its skills as MCP-compatible resources, especially if those skills are well-defined and can be invoked in a more tool-like, stateless manner. In such a case, another agent might \"discover\" this A2A agent's specific skill via an MCP-style tool description (perhaps derived from its Agent Card).</p> <p>However, the primary strength of A2A lies in its support for more flexible, stateful, and collaborative interactions that go beyond typical tool invocation. A2A is about agents partnering on tasks, while MCP is more about agents using capabilities.</p> <p>By leveraging both A2A for inter-agent collaboration and MCP for tool integration, developers can build more powerful, flexible, and interoperable AI systems.</p>"},{"location":"topics/agent-discovery/","title":"Agent Discovery in A2A","text":"<p>For AI agents to collaborate using the Agent2Agent (A2A) protocol, they first need to find each other and understand what capabilities the other agents offer. A2A standardizes the format of an agent's self-description through the Agent Card. However, the methods for discovering these Agent Cards can vary depending on the environment and requirements.</p>"},{"location":"topics/agent-discovery/#the-role-of-the-agent-card","title":"The Role of the Agent Card","text":"<p>The Agent Card is a JSON document that serves as a digital \"business card\" for an A2A Server (the remote agent). It is crucial for discovery and initiating interaction. Key information typically included in an Agent Card:</p> <ul> <li>Identity: <code>name</code>, <code>description</code>, <code>provider</code> information.</li> <li>Service Endpoint: The <code>url</code> where the A2A service can be reached.</li> <li>A2A Capabilities: Supported protocol features like <code>streaming</code> or <code>pushNotifications</code>.</li> <li>Authentication: Required authentication <code>schemes</code> (e.g., \"Bearer\", \"OAuth2\") to interact with the agent.</li> <li>Skills: A list of specific tasks or functions the agent can perform (<code>AgentSkill</code> objects), including their <code>id</code>, <code>name</code>, <code>description</code>, <code>inputModes</code>, <code>outputModes</code>, and <code>examples</code>.</li> </ul> <p>Client agents parse the Agent Card to determine if a remote agent is suitable for a given task, how to structure requests for its skills, and how to communicate with it securely.</p>"},{"location":"topics/agent-discovery/#discovery-strategies","title":"Discovery Strategies","text":"<p>Here are common strategies for how a client agent might discover the Agent Card of a remote agent:</p>"},{"location":"topics/agent-discovery/#1-well-known-uri","title":"1. Well-Known URI","text":"<p>This is a recommended approach for public agents or agents intended for broad discoverability within a specific domain.</p> <ul> <li>Mechanism: A2A Servers host their Agent Card at a standardized, \"well-known\" path on their domain.</li> <li>Standard Path: <code>https://{agent-server-domain}/.well-known/agent.json</code> (following the principles of RFC 8615 for well-known URIs).</li> <li>Process:<ol> <li>A client agent knows or programmatically discovers the domain of a potential A2A Server (e.g., <code>smart-thermostat.example.com</code>).</li> <li>The client performs an HTTP <code>GET</code> request to <code>https://smart-thermostat.example.com/.well-known/agent.json</code>.</li> <li>If the Agent Card exists and is accessible, the server returns it as a JSON response.</li> </ol> </li> <li>Advantages: Simple, standardized, and enables automated discovery by crawlers or systems that can resolve domains. Effectively reduces the discovery problem to \"find the agent's domain.\"</li> <li>Considerations: Best suited for agents intended for open discovery or discovery within an organization that controls the domain. The endpoint serving the Agent Card may itself require authentication if the card contains sensitive information.</li> </ul>"},{"location":"topics/agent-discovery/#2-curated-registries-catalog-based-discovery","title":"2. Curated Registries (Catalog-Based Discovery)","text":"<p>For enterprise environments, marketplaces, or specialized ecosystems, Agent Cards can be published to and discovered via a central registry or catalog.</p> <ul> <li>Mechanism: An intermediary service (the registry) maintains a collection of Agent Cards. Clients query this registry to find agents based on various criteria (e.g., skills offered, tags, provider name, desired capabilities).</li> <li>Process:<ol> <li>A2A Servers (or their administrators) register their Agent Cards with the registry service. The mechanism for this registration is outside the scope of the A2A protocol itself.</li> <li>Client agents query the registry's API (e.g., \"find agents with 'image-generation' skill that support streaming\").</li> <li>The registry returns a list of matching Agent Cards or references to them.</li> </ol> </li> <li>Advantages:<ul> <li>Centralized management, curation, and governance of available agents.</li> <li>Facilitates discovery based on functional capabilities rather than just domain names.</li> <li>Can implement access controls, policies, and trust mechanisms at the registry level.</li> <li>Enables scenarios like company-specific or team-specific agent catalogs, or public marketplaces of A2A-compliant agents.</li> </ul> </li> <li>Considerations: Requires an additional registry service. The A2A protocol does not currently define a standard API for such registries, though this is an area of potential future exploration and community standardization.</li> </ul>"},{"location":"topics/agent-discovery/#3-direct-configuration-private-discovery","title":"3. Direct Configuration / Private Discovery","text":"<p>In many scenarios, especially within tightly coupled systems, for private agents, or during development and testing, clients might be directly configured with Agent Card information or a URL to fetch it.</p> <ul> <li>Mechanism: The client application has hardcoded Agent Card details, reads them from a local configuration file, receives them through an environment variable, or fetches them from a private, proprietary API endpoint known to the client.</li> <li>Process: This is highly specific to the application's deployment and configuration strategy.</li> <li>Advantages: Simple and effective for known, static relationships between agents or when dynamic discovery is not a requirement.</li> <li>Considerations: Less flexible for discovering new or updated agents dynamically. Changes to the remote agent's card might require re-configuration of the client. Proprietary API-based discovery is not standardized by A2A.</li> </ul>"},{"location":"topics/agent-discovery/#securing-agent-cards","title":"Securing Agent Cards","text":"<p>Agent Cards themselves can sometimes contain information that should be protected, such as:</p> <ul> <li>The <code>url</code> of an internal-only or restricted-access agent.</li> <li>Details in the <code>authentication.credentials</code> field if it's used for scheme-specific, non-secret information (e.g., an OAuth token URL). Storing actual plaintext secrets in an Agent Card is strongly discouraged.</li> <li>Descriptions of sensitive or internal skills.</li> </ul> <p>Protection Mechanisms:</p> <ul> <li>Access Control on the Endpoint: The HTTP endpoint serving the Agent Card (whether it's the <code>/.well-known/agent.json</code> path, a registry API, or a custom URL) should be secured using standard web practices if the card is not intended for public, unauthenticated access.<ul> <li>mTLS: Require mutual TLS for client authentication if appropriate for the trust model.</li> <li>Network Restrictions: Limit access to specific IP ranges, VPCs, or private networks.</li> <li>Authentication: Require standard HTTP authentication (e.g., OAuth 2.0 Bearer token, API Key) to access the Agent Card itself.</li> </ul> </li> <li>Selective Disclosure by Registries: Agent registries can implement logic to return different Agent Cards or varying levels of detail based on the authenticated client's identity and permissions. For example, a public query might return a limited card, while an authenticated partner query might receive a card with more details.</li> </ul> <p>It's crucial to remember that if an Agent Card were to contain sensitive data (again, not recommended for secrets), the card itself must never be available without strong authentication and authorization. The A2A protocol encourages authentication schemes where the client obtains dynamic credentials out-of-band, rather than relying on static secrets embedded in the Agent Card.</p>"},{"location":"topics/agent-discovery/#future-considerations","title":"Future Considerations","text":"<p>The A2A community may explore standardizing aspects of registry interactions or more advanced, semantic discovery protocols in the future. Feedback and contributions in this area are welcome to enhance the discoverability and interoperability of A2A agents.</p>"},{"location":"topics/enterprise-ready/","title":"Enterprise-Ready Features for A2A Agents","text":"<p>The Agent2Agent (A2A) protocol is designed with enterprise requirements at its core. Instead of inventing new, proprietary standards for security and operations, A2A aims to integrate seamlessly with existing enterprise infrastructure and widely adopted best practices. A2A treats remote agents as standard, HTTP-based enterprise applications. This approach allows organizations to leverage their existing investments and expertise in security, monitoring, governance, and identity management.</p> <p>A key principle of A2A is that agents are typically \"opaque\" \u2013 they do not share internal memory, tools, or direct resource access with each other. This opacity naturally aligns with standard client/server security paradigms.</p>"},{"location":"topics/enterprise-ready/#1-transport-level-security-tls","title":"1. Transport Level Security (TLS)","text":"<p>Ensuring the confidentiality and integrity of data in transit is fundamental.</p> <ul> <li>HTTPS Mandate: All A2A communication in production environments MUST occur over HTTPS.</li> <li>Modern TLS Standards: Implementations SHOULD use modern TLS versions (TLS 1.2 or higher is recommended) with strong, industry-standard cipher suites to protect data from eavesdropping and tampering.</li> <li>Server Identity Verification: A2A Clients SHOULD verify the A2A Server's identity by validating its TLS certificate against trusted certificate authorities (CAs) during the TLS handshake. This prevents man-in-the-middle attacks.</li> </ul>"},{"location":"topics/enterprise-ready/#2-authentication","title":"2. Authentication","text":"<p>A2A delegates authentication to standard web mechanisms, primarily relying on HTTP headers. Authentication requirements are advertised by the A2A Server in its Agent Card.</p> <ul> <li>No In-Payload Identity: A2A protocol payloads (JSON-RPC messages) do not carry user or client identity information. Identity is established at the transport/HTTP layer.</li> <li>Agent Card Declaration: The A2A Server's <code>AgentCard</code> specifies the required authentication <code>schemes</code> (e.g., \"Bearer\", \"OAuth2\", \"ApiKey\", \"Basic\") in its <code>authentication</code> object. These scheme names often align with those defined in the OpenAPI Specification for authentication.</li> <li>Out-of-Band Credential Acquisition: The A2A Client is responsible for obtaining the necessary credential materials (e.g., OAuth 2.0 tokens, API keys, JWTs) through processes external to the A2A protocol itself. This could involve OAuth flows (authorization code, client credentials), secure key distribution, etc.</li> <li>HTTP Header Transmission: Credentials MUST be transmitted in standard HTTP headers as per the requirements of the chosen authentication scheme (e.g., <code>Authorization: Bearer &lt;token&gt;</code>, <code>X-API-Key: &lt;key_value&gt;</code>).</li> <li>Server-Side Validation: The A2A Server MUST authenticate every incoming request based on the credentials provided in the HTTP headers and its declared requirements.<ul> <li>If authentication fails or is missing, the server SHOULD respond with standard HTTP status codes such as <code>401 Unauthorized</code> or <code>403 Forbidden</code>.</li> <li>A <code>401 Unauthorized</code> response SHOULD include a <code>WWW-Authenticate</code> header indicating the required scheme(s), guiding the client on how to authenticate correctly.</li> </ul> </li> <li>In-Task Authentication (Secondary Credentials): If an agent, during a task, requires additional credentials for a different system (e.g., to access a specific tool on behalf of the user), A2A recommends:<ol> <li>The A2A Server transitions the A2A task to the <code>input-required</code> state.</li> <li>The <code>TaskStatus.message</code> (often using a <code>DataPart</code>) should provide details about the required authentication for the secondary system, potentially using an <code>AuthenticationInfo</code>-like structure.</li> <li>The A2A Client then obtains these new credentials out-of-band for the secondary system. These credentials might be provided back to the A2A Server (if it's proxying the request) or used by the client to interact directly with the secondary system.</li> </ol> </li> </ul>"},{"location":"topics/enterprise-ready/#3-authorization","title":"3. Authorization","text":"<p>Once a client is authenticated, the A2A Server is responsible for authorizing the request. Authorization logic is specific to the agent's implementation, the data it handles, and applicable enterprise policies.</p> <ul> <li>Granular Control: Authorization SHOULD be applied based on the authenticated identity (which could represent an end-user, a client application, or both).</li> <li>Skill-Based Authorization: Access can be controlled on a per-skill basis, as advertised in the Agent Card. For example, specific OAuth scopes might grant an authenticated client access to invoke certain skills but not others.</li> <li>Data and Action-Level Authorization: Agents that interact with backend systems, databases, or tools MUST enforce appropriate authorization before performing sensitive actions or accessing sensitive data through those underlying resources. The agent acts as a gatekeeper.</li> <li>Principle of Least Privilege: Grant only the necessary permissions required for a client or user to perform their intended operations via the A2A interface.</li> </ul>"},{"location":"topics/enterprise-ready/#4-data-privacy-and-confidentiality","title":"4. Data Privacy and Confidentiality","text":"<ul> <li>Sensitivity Awareness: Implementers must be acutely aware of the sensitivity of data exchanged in <code>Message</code> and <code>Artifact</code> parts of A2A interactions.</li> <li>Compliance: Ensure compliance with relevant data privacy regulations (e.g., GDPR, CCPA, HIPAA, depending on the domain and data).</li> <li>Data Minimization: Avoid including or requesting unnecessarily sensitive information in A2A exchanges.</li> <li>Secure Handling: Protect data both in transit (via TLS, as mandated) and at rest (if persisted by agents) according to enterprise data security policies and regulatory requirements.</li> </ul>"},{"location":"topics/enterprise-ready/#5-tracing-observability-and-monitoring","title":"5. Tracing, Observability, and Monitoring","text":"<p>A2A's reliance on HTTP allows for straightforward integration with standard enterprise tracing, logging, and monitoring tools.</p> <ul> <li>Distributed Tracing:<ul> <li>A2A Clients and Servers SHOULD participate in distributed tracing systems (e.g., OpenTelemetry, Jaeger, Zipkin).</li> <li>Trace context (trace IDs, span IDs) SHOULD be propagated via standard HTTP headers (e.g., W3C Trace Context headers like <code>traceparent</code> and <code>tracestate</code>).</li> <li>This enables end-to-end visibility of requests as they flow across multiple agents and underlying services, which is invaluable for debugging and performance analysis.</li> </ul> </li> <li>Comprehensive Logging: Implement detailed logging on both client and server sides. Logs should include relevant identifiers such as <code>taskId</code>, <code>sessionId</code>, correlation IDs, and trace context to facilitate troubleshooting and auditing.</li> <li>Metrics: A2A Servers should expose key operational metrics (e.g., request rates, error rates, task processing latency, resource utilization) to enable performance monitoring, alerting, and capacity planning. These can be integrated with systems like Prometheus or Google Cloud Monitoring.</li> <li>Auditing: Maintain audit trails for significant events, such as task creation, critical state changes, and actions performed by agents, especially those involving sensitive data access, modifications, or high-impact operations.</li> </ul>"},{"location":"topics/enterprise-ready/#6-api-management-and-governance","title":"6. API Management and Governance","text":"<p>For A2A Servers exposed externally, across organizational boundaries, or even within large enterprises, integration with API Management solutions is highly recommended. This can provide:</p> <ul> <li>Centralized Policy Enforcement: Consistent application of security policies (authentication, authorization), rate limiting, and quotas.</li> <li>Traffic Management: Load balancing, routing, and mediation.</li> <li>Analytics and Reporting: Insights into agent usage, performance, and trends.</li> <li>Developer Portals: Facilitate discovery of A2A-enabled agents, provide documentation (including Agent Cards), and streamline onboarding for client developers.</li> </ul> <p>By adhering to these enterprise-grade practices, A2A implementations can be deployed securely, reliably, and manageably within complex organizational environments, fostering trust and enabling scalable inter-agent collaboration.</p>"},{"location":"topics/key-concepts/","title":"Key Concepts in A2A","text":"<p>The Agent2Agent (A2A) protocol is built around a set of core concepts that define how agents interact. Understanding these concepts is crucial for developing or integrating with A2A-compliant systems.</p> <p></p>"},{"location":"topics/key-concepts/#core-actors","title":"Core Actors","text":"<ul> <li>User: The end-user (human or automated service) who initiates a request or goal that requires agent assistance.</li> <li>A2A Client (Client Agent): An application, service, or another AI agent that acts on behalf of the user to request actions or information from a remote agent. The client initiates communication using the A2A protocol.</li> <li>A2A Server (Remote Agent): An AI agent or agentic system that exposes an HTTP endpoint implementing the A2A protocol. It receives requests from clients, processes tasks, and returns results or status updates. The remote agent operates as an \"opaque\" system from the client's perspective, meaning the client doesn't need to know its internal workings, memory, or tools.</li> </ul>"},{"location":"topics/key-concepts/#fundamental-communication-elements","title":"Fundamental Communication Elements","text":"<ul> <li> <p>Agent Card:</p> <ul> <li>A JSON metadata document, typically discoverable at a well-known URL (e.g., <code>/.well-known/agent.json</code>), that describes an A2A Server.</li> <li>It details the agent's identity (name, description), service endpoint URL, version, supported A2A capabilities (like streaming or push notifications), specific skills it offers, default input/output modalities, and authentication requirements.</li> <li>Clients use the Agent Card to discover agents and understand how to interact with them securely and effectively.</li> <li>See details in the Protocol Specification: Agent Card.</li> </ul> </li> <li> <p>Task:</p> <ul> <li>The central unit of work in A2A. A client initiates a task to achieve a specific goal (e.g., \"generate a report,\" \"book a flight,\" \"answer a question\").</li> <li>Each task has a unique ID (typically client-generated) and progresses through a defined lifecycle (e.g., <code>submitted</code>, <code>working</code>, <code>input-required</code>, <code>completed</code>, <code>failed</code>).</li> <li>Tasks are stateful and can involve multiple exchanges (messages) between the client and the server.</li> <li>See details in the Protocol Specification: Task Object.</li> </ul> </li> <li> <p>Message:</p> <ul> <li>Represents a single turn or unit of communication within a Task.</li> <li>Messages have a <code>role</code> (either <code>\"user\"</code> for client-sent messages or <code>\"agent\"</code> for server-sent messages) and contain one or more <code>Part</code> objects that carry the actual content.</li> <li>Used for conveying instructions, context, questions, answers, or status updates that are not necessarily formal <code>Artifacts</code>.</li> <li>See details in the Protocol Specification: Message Object.</li> </ul> </li> <li> <p>Part:</p> <ul> <li>The fundamental unit of content within a <code>Message</code> or an <code>Artifact</code>. Each part has a specific <code>type</code> and can carry different kinds of data:<ul> <li><code>TextPart</code>: Contains plain textual content.</li> <li><code>FilePart</code>: Represents a file, which can be transmitted as inline base64-encoded bytes or referenced via a URI. Includes metadata like filename and MIME type.</li> <li><code>DataPart</code>: Carries structured JSON data, useful for forms, parameters, or any machine-readable information.</li> </ul> </li> <li>See details in the Protocol Specification: Part Union Type.</li> </ul> </li> <li> <p>Artifact:</p> <ul> <li>Represents a tangible output or result generated by the remote agent during the processing of a task.</li> <li>Examples include generated documents, images, spreadsheets, structured data results, or any other self-contained piece of information that is a direct result of the task.</li> <li>Artifacts are composed of one or more <code>Part</code> objects and can be streamed incrementally.</li> <li>See details in the Protocol Specification: Artifact Object.</li> </ul> </li> </ul>"},{"location":"topics/key-concepts/#interaction-mechanisms","title":"Interaction Mechanisms","text":"<ul> <li> <p>Request/Response (Polling):</p> <ul> <li>The client sends a request (e.g., using the <code>tasks/send</code> RPC method) and receives a response from the server.</li> <li>For long-running tasks, the server might initially respond with a <code>working</code> status. The client would then periodically call <code>tasks/get</code> to poll for updates until the task reaches a terminal state (e.g., <code>completed</code>, <code>failed</code>).</li> </ul> </li> <li> <p>Streaming (Server-Sent Events - SSE):</p> <ul> <li>For tasks that produce results incrementally or provide real-time progress updates.</li> <li>The client initiates a task using <code>tasks/sendSubscribe</code>.</li> <li>The server responds with an HTTP connection that remains open, over which it sends a stream of Server-Sent Events (SSE).</li> <li>These events can be <code>TaskStatusUpdateEvent</code> (for status changes) or <code>TaskArtifactUpdateEvent</code> (for new or updated artifact chunks).</li> <li>This requires the server to advertise the <code>streaming</code> capability in its Agent Card.</li> <li>Learn more about Streaming &amp; Asynchronous Operations.</li> </ul> </li> <li> <p>Push Notifications:</p> <ul> <li>For very long-running tasks or scenarios where maintaining a persistent connection (like SSE) is impractical.</li> <li>The client can provide a webhook URL when initiating a task (or by calling <code>tasks/pushNotification/set</code>).</li> <li>When the task status changes significantly (e.g., completes, fails, or requires input), the server can send an asynchronous notification (an HTTP POST request) to this client-provided webhook.</li> <li>This requires the server to advertise the <code>pushNotifications</code> capability in its Agent Card.</li> <li>Learn more about Streaming &amp; Asynchronous Operations.</li> </ul> </li> </ul>"},{"location":"topics/key-concepts/#other-important-concepts","title":"Other Important Concepts","text":"<ul> <li>Session (<code>sessionId</code>): An optional client-generated identifier that can be used to logically group multiple related <code>Task</code> objects, providing context across a series of interactions.</li> <li>Transport and Format: A2A communication occurs over HTTP(S). JSON-RPC 2.0 is used as the payload format for all requests and responses.</li> <li>Authentication &amp; Authorization: A2A relies on standard web security practices. Authentication requirements are declared in the Agent Card, and credentials (e.g., OAuth tokens, API keys) are typically passed via HTTP headers, separate from the A2A protocol messages themselves.<ul> <li>Learn more about Enterprise-Ready Features.</li> </ul> </li> <li>Agent Discovery: The process by which clients find Agent Cards to learn about available A2A Servers and their capabilities.<ul> <li>Learn more about Agent Discovery.</li> </ul> </li> </ul> <p>By understanding these core components and mechanisms, developers can effectively design, implement, and utilize A2A for building interoperable and collaborative AI agent systems.</p>"},{"location":"topics/streaming-and-async/","title":"Streaming &amp; Asynchronous Operations in A2A","text":"<p>The Agent2Agent (A2A) protocol is designed to handle tasks that may not complete immediately. Many AI-driven operations can be long-running, involve multiple steps, produce incremental results, or require human intervention. A2A provides robust mechanisms for managing such asynchronous interactions, ensuring that clients can receive updates effectively, whether they remain continuously connected or operate in a more disconnected fashion.</p>"},{"location":"topics/streaming-and-async/#1-streaming-with-server-sent-events-sse","title":"1. Streaming with Server-Sent Events (SSE)","text":"<p>For tasks that produce incremental results (like generating a long document or streaming media) or provide ongoing status updates, A2A supports real-time communication using Server-Sent Events (SSE). This is ideal when the client can maintain an active HTTP connection with the A2A Server.</p> <p>Key Characteristics:</p> <ul> <li>Initiation: The client uses the <code>tasks/sendSubscribe</code> RPC method to send an initial message (e.g., a prompt or command) and simultaneously subscribe to updates for that task.</li> <li>Server Capability: The A2A Server must indicate its support for streaming by setting <code>capabilities.streaming: true</code> in its Agent Card.</li> <li>Server Response (Connection): If the subscription is successful, the server responds with an HTTP <code>200 OK</code> status and a <code>Content-Type: text/event-stream</code>. This HTTP connection remains open for the server to push events.</li> <li>Event Structure: The server sends events over this stream. Each event's <code>data</code> field contains a JSON-RPC 2.0 Response object, specifically a <code>SendTaskStreamingResponse</code>. The <code>id</code> in this JSON-RPC response matches the <code>id</code> from the client's original <code>tasks/sendSubscribe</code> request.</li> <li>Event Types (within <code>SendTaskStreamingResponse.result</code>):<ul> <li><code>TaskStatusUpdateEvent</code>: Communicates changes in the task's lifecycle state (e.g., from <code>working</code> to <code>input-required</code> or <code>completed</code>). It can also provide intermediate messages from the agent (e.g., \"I'm currently analyzing the data...\").</li> <li><code>TaskArtifactUpdateEvent</code>: Delivers new or updated Artifacts generated by the task. This is used to stream large files or data structures in chunks. The <code>Artifact</code> object itself contains fields like <code>index</code>, <code>append</code>, and <code>lastChunk</code> to help the client reassemble the complete artifact.</li> </ul> </li> <li>Stream Termination: The server signals the end of updates for a particular interaction cycle (i.e., for the current <code>tasks/sendSubscribe</code> request) by setting <code>final: true</code> in a <code>TaskStatusUpdateEvent</code>. This typically occurs when the task reaches a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>) or an <code>input-required</code> state (where the server expects further input from the client). After sending a <code>final: true</code> event, the server usually closes the SSE connection for that specific request.</li> <li>Resubscription: If a client's SSE connection breaks prematurely while a task is still active (and the server hasn't sent a <code>final: true</code> event for that phase), the client can attempt to reconnect to the stream using the <code>tasks/resubscribe</code> RPC method. The server's behavior regarding missed events during the disconnection period (e.g., whether it backfills or only sends new updates) is implementation-dependent.</li> </ul> <p>When to Use Streaming:</p> <ul> <li>Real-time progress monitoring of long-running tasks.</li> <li>Receiving large results (artifacts) incrementally, allowing processing to begin before the entire result is available.</li> <li>Interactive, conversational exchanges where immediate feedback or partial responses are beneficial.</li> <li>Applications requiring low-latency updates from the agent.</li> </ul> <p>Refer to the Protocol Specification for detailed structures:</p> <ul> <li><code>tasks/sendSubscribe</code></li> <li><code>tasks/resubscribe</code></li> </ul>"},{"location":"topics/streaming-and-async/#2-push-notifications-for-disconnected-scenarios","title":"2. Push Notifications for Disconnected Scenarios","text":"<p>For very long-running tasks (e.g., lasting minutes, hours, or even days) or when clients cannot or prefer not to maintain persistent connections (like mobile clients or serverless functions), A2A supports asynchronous updates via push notifications. This mechanism allows the A2A Server to actively notify a client-provided webhook when a significant task update occurs.</p> <p>Key Characteristics:</p> <ul> <li>Server Capability: The A2A Server must indicate its support for this feature by setting <code>capabilities.pushNotifications: true</code> in its Agent Card.</li> <li>Configuration: The client provides a <code>PushNotificationConfig</code> to the server. This configuration can be supplied:<ul> <li>Within the initial <code>tasks/send</code> or <code>tasks/sendSubscribe</code> request (via the optional <code>pushNotification</code> parameter in <code>TaskSendParams</code>).</li> <li>Separately, using the <code>tasks/pushNotification/set</code> RPC method for an existing task. The <code>PushNotificationConfig</code> includes:</li> <li><code>url</code>: The absolute HTTPS webhook URL where the A2A Server should send (POST) task update notifications.</li> <li><code>token</code> (optional): A client-generated opaque string (e.g., a secret or task-specific identifier). The server SHOULD include this token in the notification request (e.g., in a custom header like <code>X-A2A-Notification-Token</code>) for validation by the client's webhook receiver.</li> <li><code>authentication</code> (optional): An <code>AuthenticationInfo</code> object specifying how the A2A Server should authenticate itself to the client's webhook URL. The client (receiver of the webhook) defines these authentication requirements.</li> </ul> </li> <li>Notification Trigger: The A2A Server decides when to send a push notification. Typically, this happens when a task reaches a significant state change, such as transitioning to a terminal state (<code>completed</code>, <code>failed</code>, <code>canceled</code>) or an <code>input-required</code> state, particularly after its associated message and artifacts are fully generated and stable.</li> <li>Notification Payload: The A2A protocol itself does not strictly define the HTTP body payload of the push notification sent by the server to the client's webhook. However, the notification SHOULD contain sufficient information for the client to identify the <code>taskId</code> and understand the general nature of the update (e.g., the new <code>TaskState</code>). Servers might send a minimal payload (just <code>taskId</code> and new state) or a more comprehensive one (e.g., a summary or even the full <code>Task</code> object).</li> <li>Client Action: Upon receiving a push notification (and successfully verifying its authenticity and relevance), the client typically uses the <code>tasks/get</code> RPC method with the <code>taskId</code> from the notification to retrieve the complete, updated <code>Task</code> object, including any new artifacts or detailed messages.</li> </ul> <p>The Push Notification Service (Client-Side Webhook Infrastructure):</p> <ul> <li>The target <code>url</code> specified in <code>PushNotificationConfig.url</code> points to a Push Notification Service. This service is a component on the client's side (or a service the client subscribes to) responsible for receiving the HTTP POST notification from the A2A Server.</li> <li>Its responsibilities include:<ul> <li>Authenticating the incoming notification (i.e., verifying it's from the legitimate A2A Server).</li> <li>Validating the notification's relevance (e.g., checking the <code>token</code>).</li> <li>Relaying the notification or its content to the appropriate client application logic or system.</li> </ul> </li> <li>In simple scenarios (e.g., local development), the client application itself might directly expose the webhook endpoint.</li> <li>In enterprise or production settings, this is often a robust, secure service that handles incoming webhooks, authenticates callers, and routes messages (e.g., to a message queue, an internal API, a mobile push notification gateway, or another event-driven system).</li> </ul>"},{"location":"topics/streaming-and-async/#security-considerations-for-push-notifications","title":"Security Considerations for Push Notifications","text":"<p>Security is paramount for push notifications due to their asynchronous and server-initiated outbound nature. Both the A2A Server (sending the notification) and the client's webhook receiver have responsibilities.</p>"},{"location":"topics/streaming-and-async/#a2a-server-security-when-sending-notifications-to-client-webhook","title":"A2A Server Security (When Sending Notifications to Client Webhook)","text":"<ol> <li> <p>Webhook URL Validation:</p> <ul> <li>Servers SHOULD NOT blindly trust and send POST requests to any <code>url</code> provided by a client in <code>PushNotificationConfig</code>. Malicious clients could provide URLs pointing to internal services or unrelated third-party systems to cause harm (Server-Side Request Forgery - SSRF attacks) or act as Distributed Denial of Service (DDoS) amplifiers.</li> <li>Mitigation Strategies:<ul> <li>Allowlisting: Maintain an allowlist of trusted domains or IP ranges for webhook URLs, if feasible.</li> <li>Ownership Verification / Challenge-Response: Before sending actual notifications, the server can (and SHOULD ideally) perform a verification step. For example, it could issue an HTTP <code>GET</code> or <code>OPTIONS</code> request to the proposed webhook URL with a unique <code>validationToken</code> (as a query parameter or header). The webhook service must respond appropriately (e.g., echo back the token or confirm readiness) to prove ownership and reachability. The A2A Python samples demonstrate a simple validation token check mechanism.</li> <li>Network Controls: Use egress firewalls or network policies to restrict where the A2A Server can send outbound HTTP requests.</li> </ul> </li> </ul> </li> <li> <p>Authenticating to the Client's Webhook:</p> <ul> <li>The A2A Server MUST authenticate itself to the client's webhook URL according to the scheme(s) specified in <code>PushNotificationConfig.authentication</code>.</li> <li>Common authentication schemes for server-to-server webhooks include:<ul> <li>Bearer Tokens (OAuth 2.0): The A2A Server obtains an access token (e.g., using the OAuth 2.0 client credentials grant flow if the webhook provider supports it) for an audience/scope representing the client's webhook, and includes it in the <code>Authorization: Bearer &lt;token&gt;</code> header of the notification POST request.</li> <li>API Keys: A pre-shared API key that the A2A Server includes in a specific HTTP header (e.g., <code>X-Api-Key</code>).</li> <li>HMAC Signatures: The A2A Server signs the request payload (or parts of the request) with a shared secret key using HMAC, and includes the signature in a header (e.g., <code>X-Hub-Signature</code>). The webhook receiver then verifies this signature.</li> <li>Mutual TLS (mTLS): If supported by the client's webhook infrastructure, the A2A Server can present a client TLS certificate.</li> </ul> </li> </ul> </li> </ol>"},{"location":"topics/streaming-and-async/#client-webhook-receiver-security-when-receiving-notifications-from-a2a-server","title":"Client Webhook Receiver Security (When Receiving Notifications from A2A Server)","text":"<ol> <li> <p>Authenticating the A2A Server:</p> <ul> <li>The webhook endpoint MUST rigorously verify the authenticity of incoming notification requests to ensure they originate from the legitimate A2A Server and not an imposter.</li> <li>Verify Signatures/Tokens:<ul> <li>If using JWTs (e.g., as Bearer tokens), validate the JWT's signature against the A2A Server's trusted public keys (e.g., fetched from a JWKS endpoint provided by the A2A Server, if applicable). Also, validate claims like <code>iss</code> (issuer), <code>aud</code> (audience - should identify your webhook), <code>iat</code> (issued at), and <code>exp</code> (expiration time).</li> <li>If using HMAC signatures, recalculate the signature on the received payload using the shared secret and compare it to the signature in the request header.</li> <li>If using API keys, ensure the key is valid and known.</li> </ul> </li> <li>Validate <code>PushNotificationConfig.token</code>: If the client provided an opaque <code>token</code> in its <code>PushNotificationConfig</code> when setting up notifications for the task, the webhook should check that the incoming notification includes this exact token (e.g., in a custom header like <code>X-A2A-Notification-Token</code>). This helps ensure the notification is intended for this specific client context and task, adding a layer of authorization.</li> </ul> </li> <li> <p>Preventing Replay Attacks:</p> <ul> <li>Timestamps: Notifications should ideally include a timestamp (e.g., <code>iat</code> - issued at - claim in a JWT, or a custom timestamp header). The webhook should reject notifications that are too old (e.g., older than a few minutes) to prevent attackers from replaying old, captured notifications. The timestamp should be part of the signed payload (if using signatures) to ensure its integrity.</li> <li>Nonces/Unique IDs: For critical notifications, consider using unique, single-use identifiers (nonces or event IDs) for each notification. The webhook should track received IDs (for a reasonable window) to prevent processing duplicate notifications. A JWT's <code>jti</code> (JWT ID) claim can serve this purpose.</li> </ul> </li> <li> <p>Secure Key Management and Rotation:</p> <ul> <li>If using cryptographic keys (symmetric secrets for HMAC, or asymmetric key pairs for JWT signing/mTLS), implement secure key management practices, including regular key rotation.</li> <li>For asymmetric keys where the A2A Server signs and the client webhook verifies, protocols like JWKS (JSON Web Key Set) allow the server to publish its public keys (including new ones during rotation) at a well-known endpoint. Client webhooks can then dynamically fetch the correct public key for signature verification, facilitating smoother key rotation.</li> </ul> </li> </ol>"},{"location":"topics/streaming-and-async/#example-asymmetric-key-flow-jwt-jwks","title":"Example Asymmetric Key Flow (JWT + JWKS)","text":"<ol> <li>Client sets <code>PushNotificationConfig</code> specifying <code>authentication.schemes: [\"Bearer\"]</code> and possibly an expected <code>issuer</code> or <code>audience</code> for the JWT.</li> <li>A2A Server, when sending a notification:<ul> <li>Generates a JWT, signing it with its private key. The JWT includes claims like <code>iss</code> (issuer), <code>aud</code> (audience - the webhook), <code>iat</code> (issued at), <code>exp</code> (expires), <code>jti</code> (JWT ID), and <code>taskId</code>.</li> <li>The JWT header (<code>alg</code> and <code>kid</code>) indicates the signing algorithm and key ID.</li> <li>The A2A Server makes its public keys available via a JWKS endpoint (URL for this endpoint might be known to the webhook provider or discovered).</li> </ul> </li> <li>Client Webhook, upon receiving the notification:<ul> <li>Extracts the JWT from the <code>Authorization</code> header.</li> <li>Inspects the <code>kid</code> in the JWT header.</li> <li>Fetches the corresponding public key from the A2A Server's JWKS endpoint (caching keys is recommended).</li> <li>Verifies the JWT signature using the public key.</li> <li>Validates claims (<code>iss</code>, <code>aud</code>, <code>iat</code>, <code>exp</code>, <code>jti</code>).</li> <li>Checks the <code>PushNotificationConfig.token</code> if provided.</li> </ul> </li> </ol> <p>This comprehensive, layered approach to security for push notifications ensures that messages are authentic, integral, and timely, protecting both the sending A2A Server and the receiving client webhook infrastructure.</p>"},{"location":"topics/what-is-a2a/","title":"What is A2A?","text":"<p>The Agent2Agent (A2A) Protocol is an open standard designed to solve a fundamental challenge in the rapidly evolving landscape of artificial intelligence: how do AI agents, built by different teams, using different technologies, and owned by different organizations, communicate and collaborate effectively?</p> <p>As AI agents become more specialized and capable, the need for them to work together on complex tasks increases. Imagine a user asking their primary AI assistant to plan an international trip. This single request might involve coordinating the capabilities of several specialized agents:</p> <ol> <li>An agent for flight bookings.</li> <li>Another agent for hotel reservations.</li> <li>A third for local tour recommendations and bookings.</li> <li>A fourth to handle currency conversion and travel advisories.</li> </ol> <p>Without a common communication protocol, integrating these diverse agents into a cohesive user experience is a significant engineering hurdle. Each integration would likely be a custom, point-to-point solution, making the system difficult to scale, maintain, and extend.</p>"},{"location":"topics/what-is-a2a/#the-a2a-solution","title":"The A2A Solution","text":"<p>A2A provides a standardized way for these independent, often \"opaque\" (black-box) agentic systems to interact. It defines:</p> <ul> <li>A common transport and format: JSON-RPC 2.0 over HTTP(S) for how messages are structured and transmitted.</li> <li>Discovery mechanisms (Agent Cards): How agents can advertise their capabilities and be found by other agents.</li> <li>Task management workflows: How collaborative tasks are initiated, progressed, and completed. This includes support for tasks that may be long-running or require multiple turns of interaction.</li> <li>Support for various data modalities: How agents exchange not just text, but also files, structured data (like forms), and potentially other rich media.</li> <li>Core principles for security and asynchronicity: Guidelines for secure communication and handling tasks that might take significant time or involve human-in-the-loop processes.</li> </ul>"},{"location":"topics/what-is-a2a/#key-design-principles-of-a2a","title":"Key Design Principles of A2A","text":"<p>The development of A2A is guided by several core principles:</p> <ul> <li>Simplicity: Leverage existing, well-understood standards like HTTP, JSON-RPC, and Server-Sent Events (SSE) where possible, rather than reinventing the wheel.</li> <li>Enterprise Readiness: Address critical enterprise needs such as authentication, authorization, security, privacy, tracing, and monitoring from the outset by aligning with standard web practices.</li> <li>Asynchronous First: Natively support long-running tasks and scenarios where agents or users might not be continuously connected, through mechanisms like streaming and push notifications.</li> <li>Modality Agnostic: Allow agents to communicate using a variety of content types, enabling rich and flexible interactions beyond plain text.</li> <li>Opaque Execution: Enable collaboration without requiring agents to expose their internal logic, memory, or proprietary tools. Agents interact based on declared capabilities and exchanged context, preserving intellectual property and enhancing security.</li> </ul>"},{"location":"topics/what-is-a2a/#benefits-of-using-a2a","title":"Benefits of Using A2A","text":"<p>Adopting A2A can lead to significant advantages:</p> <ul> <li>Increased Interoperability: Break down silos between different AI agent ecosystems, allowing agents from various vendors and frameworks to work together.</li> <li>Enhanced Agent Capabilities: Allow developers to create more sophisticated applications by composing the strengths of multiple specialized agents.</li> <li>Reduced Integration Complexity: Standardize the \"how\" of agent communication, allowing teams to focus on the \"what\" \u2013 the value their agents provide.</li> <li>Fostering Innovation: Encourage the development of a richer ecosystem of specialized agents that can readily plug into larger collaborative workflows.</li> <li>Future-Proofing: Provide a flexible framework that can adapt as agent technologies continue to evolve.</li> </ul> <p>By establishing common ground for agent-to-agent communication, A2A aims to accelerate the adoption and utility of AI agents across diverse industries and applications, paving the way for more powerful and collaborative AI systems.</p> <p>Watch the A2A Demo Video</p> <p>Next, learn about the Key Concepts that form the foundation of the A2A protocol.</p>"},{"location":"tutorials/python/1-introduction/","title":"Python Quickstart Tutorial: Building an A2A Agent","text":"<p>Welcome to the Agent2Agent (A2A) Python Quickstart Tutorial!</p> <p>In this tutorial, you will build a simple \"echo\" A2A server using Python. This initial barebones implementation will introduce you to the fundamental concepts and components of an A2A server. You will then progressively enhance this server, culminating in an agent powered by a local Ollama model.</p> <p>This hands-on guide will help you understand:</p> <ul> <li>The basic concepts behind the A2A protocol.</li> <li>How to set up a Python project for A2A development.</li> <li>How to define Agent Skills and create an Agent Card.</li> <li>How to implement a basic A2A server that handles tasks.</li> <li>How to interact with your A2A server using a client.</li> <li>How to incorporate streaming capabilities and handle multi-turn interactions.</li> <li>How to integrate a Large Language Model (LLM) using Ollama to create a more intelligent agent.</li> </ul> <p>By the end of this tutorial, you will have a functional A2A agent and a solid foundation for building more complex A2A-compliant applications.</p>"},{"location":"tutorials/python/1-introduction/#tutorial-sections","title":"Tutorial Sections","text":"<p>The tutorial is broken down into the following steps:</p> <ol> <li>Introduction (This Page)</li> <li>Setup: Prepare your Python environment.</li> <li>Create Project: Initialize your project structure.</li> <li>Agent Skills: Define what your agent can do.</li> <li>Add Agent Card: Describe your agent to the world.</li> <li>Start Server: Implement the A2A server logic.</li> <li>Interact with Server: Send requests to your agent.</li> <li>Agent Capabilities: Add streaming and asynchronous features.</li> <li>Ollama Agent: Integrate an LLM to power your agent.</li> <li>Next Steps: Explore further possibilities with A2A.</li> </ol> <p>Let's get started!</p> <p>Proceed to Setup</p>"},{"location":"tutorials/python/10-next-steps/","title":"Next Steps","text":"<p>Congratulations! You now have mastered the basics of running an A2A server with an AI model as the agent. Here's some ideas of where to go next.</p> <ul> <li>Connect our AI model with [MCP tools]</li> <li>Hint: first create a MCP Server</li> <li>Then: Integrate MCP Tools into our existing call to <code>create_react_agent(ollama_chat_llm, tools=[])</code></li> <li>Develop your own agent using Google's Agent Development Kit or other framework. Check out the A2A samples</li> <li>\ud83d\udcda Read the A2A technical documentation to understand the capabilities</li> <li>\ud83d\udcdd Review the A2A specification of the protocol structures</li> <li>\ud83d\udcd1 Review key topics to understand protocol details</li> <li>A2A and MCP</li> <li>Enterprise Ready</li> <li>Streaming &amp; Asynchronous Operations</li> <li>Agent Discovery</li> </ul> <p>Prev</p>"},{"location":"tutorials/python/2-setup/","title":"Set up Your Environment","text":""},{"location":"tutorials/python/2-setup/#what-youll-need","title":"What You'll Need","text":"<ul> <li>A code editor such as Visual Studio Code (VS Code)</li> <li>A command prompt such as Terminal (Linux), iTerm (Mac) or just the Terminal in VS Code</li> </ul>"},{"location":"tutorials/python/2-setup/#python-environment","title":"Python Environment","text":"<p>We'll be using https://docs.astral.sh/uv/ as our package manager and to set up our project.</p> <p>The A2A libraries we'll be using require <code>python &gt;= 3.12</code> which uv can install if you don't already have a matching version. We'll be using python 3.12.</p>"},{"location":"tutorials/python/2-setup/#check","title":"Check","text":"<p>Run the following command to make sure you're ready for the next step.</p> <pre><code>echo 'import sys; print(sys.version)' | uv run -\n</code></pre> <p>If you see something similar to the following, you are ready to proceed!</p> <pre><code>3.12.3 (main, Feb  4 2025, 14:48:35) [GCC 13.3.0]\n</code></pre> <p>Prev Next</p>"},{"location":"tutorials/python/3-create-project/","title":"Creating A Project","text":"<p>Let's first create a project using <code>uv</code>. We'll add the <code>--package</code> flag in case you want to add tests, or publish your project later</p> <pre><code>uv init --package my-project\ncd my-project\n</code></pre>"},{"location":"tutorials/python/3-create-project/#using-a-virtual-env","title":"Using a Virtual Env","text":"<p>We'll create a venv for this project. This only needs to be done once</p> <pre><code>uv venv .venv\n</code></pre> <p>For this and any future terminal windows you open, you'll need to source this venv</p> <pre><code>source .venv/bin/activate\n</code></pre> <p>If you're using a code editor such as VS Code, you'll want to set the Python Interpreter for code completions. In VS Code, press <code>Ctrl-Shift-P</code> and select <code>Python: Select Interpreter</code>. Then select your project <code>my-project</code> followed by the correct python interpreter <code>Python 3.12.3 ('.venv':venv) ./.venv/bin/python</code></p> <p>The source code should now look similar to this.</p> <pre><code>tree .\n.\n\u251c\u2500\u2500 pyproject.toml\n\u251c\u2500\u2500 README.md\n\u251c\u2500\u2500 src\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 my-project\n\u2502\u00a0\u00a0     \u251c\u2500\u2500 __init__.py\n</code></pre>"},{"location":"tutorials/python/3-create-project/#adding-the-google-a2a-python-libraries","title":"Adding the Google-A2A Python Libraries","text":"<p>Next we'll add the sample A2A python libraries from Google.</p> <pre><code>uv add git+https://github.com/google/A2A#subdirectory=samples/python\n</code></pre>"},{"location":"tutorials/python/3-create-project/#setting-up-the-project-structure","title":"Setting up the project structure","text":"<p>Let's now create some files we'll later be using</p> <pre><code>touch src/my_project/agent.py\ntouch src/my_project/task_manager.py\n</code></pre>"},{"location":"tutorials/python/3-create-project/#test-run","title":"Test Run","text":"<p>If everything is setup correctly, you should now be able to run your application.</p> <pre><code>uv run my-project\n</code></pre> <p>The output should look something like this.</p> <pre><code>Hello from my-project!\n</code></pre> <p>Prev Next</p>"},{"location":"tutorials/python/4-agent-skills/","title":"Agent Skills","text":"<p>An agent skill is a set of capabilities the agent can perform. Here's an example of what it would look like for our echo agent.</p> <pre><code>{\n  id: \"my-project-echo-skill\"\n  name: \"Echo Tool\",\n  description: \"Echos the input given\",\n  tags: [\"echo\", \"repeater\"],\n  examples: [\"I will see this echoed back to me\"],\n  inputModes: [\"text\"],\n  outputModes: [\"text\"]\n}\n</code></pre> <p>This conforms to the skills section of the Agent Card</p> <pre><code>{\n  id: string; // unique identifier for the agent's skill\n  name: string; //human readable name of the skill\n  // description of the skill - will be used by the client or a human\n  // as a hint to understand what the skill does.\n  description: string;\n  // Set of tag words describing classes of capabilities for this specific\n  // skill (e.g. \"cooking\", \"customer support\", \"billing\")\n  tags: string[];\n  // The set of example scenarios that the skill can perform.\n  // Will be used by the client as a hint to understand how the skill can be\n  // used. (e.g. \"I need a recipe for bread\")\n  examples?: string[]; // example prompts for tasks\n  // The set of interaction modes that the skill supports\n  // (if different than the default)\n  inputModes?: string[]; // supported mime types for input\n  outputModes?: string[]; // supported mime types for output\n}\n</code></pre>"},{"location":"tutorials/python/4-agent-skills/#implementation","title":"Implementation","text":"<p>Let's create this Agent Skill in code. Open up <code>src/my-project/__init__.py</code> and replace the contents with the following code</p> <pre><code>import google_a2a\nfrom google_a2a.common.types import AgentSkill\n\ndef main():\n  skill = AgentSkill(\n    id=\"my-project-echo-skill\",\n    name=\"Echo Tool\",\n    description=\"Echos the input given\",\n    tags=[\"echo\", \"repeater\"],\n    examples=[\"I will see this echoed back to me\"],\n    inputModes=[\"text\"],\n    outputModes=[\"text\"],\n  )\n  print(skill)\n\nif __name__ == \"__main__\":\n  main()\n</code></pre>"},{"location":"tutorials/python/4-agent-skills/#test-run","title":"Test Run","text":"<p>Let's give this a run.</p> <pre><code>uv run my-project\n</code></pre> <p>The output should look something like this.</p> <pre><code>id='my-project-echo-skill' name='Echo Tool' description='Echos the input given' tags=['echo', 'repeater'] examples=['I will see this echoed back to me'] inputModes=['text'] outputModes=['text']\n</code></pre> <p>Prev Next</p>"},{"location":"tutorials/python/5-add-agent-card/","title":"Agent Card","text":"<p>Now that we have defined our skills, we can create an Agent Card.</p> <p>Remote Agents are required to publish an Agent Card in JSON format describing the agent's capabilities and skills in addition to authentication mechanisms. In other words, this lets the world know about your agent and how to interact with it. You can find more details in the documentation.</p>"},{"location":"tutorials/python/5-add-agent-card/#implementation","title":"Implementation","text":"<p>First lets add some helpers for parsing command line arguments. This will be helpful later for starting our server</p> <pre><code>uv add click\n</code></pre> <p>And update our code</p> <pre><code>import logging\n\nimport click\nfrom dotenv import load_dotenv\nimport google_a2a\nfrom google_a2a.common.types import AgentSkill, AgentCapabilities, AgentCard\n\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n@click.command()\n@click.option(\"--host\", default=\"localhost\")\n@click.option(\"--port\", default=10002)\ndef main(host, port):\n  skill = AgentSkill(\n    id=\"my-project-echo-skill\",\n    name=\"Echo Tool\",\n    description=\"Echos the input given\",\n    tags=[\"echo\", \"repeater\"],\n    examples=[\"I will see this echoed back to me\"],\n    inputModes=[\"text\"],\n    outputModes=[\"text\"],\n  )\n  logging.info(skill)\n\nif __name__ == \"__main__\":\n  main()\n</code></pre> <p>Next we'll add our Agent Card</p> <pre><code># ...\ndef main(host, port):\n  # ...\n  capabilities = AgentCapabilities()\n  agent_card = AgentCard(\n    name=\"Echo Agent\",\n    description=\"This agent echos the input given\",\n    url=f\"http://{host}:{port}/\",\n    version=\"0.1.0\",\n    defaultInputModes=[\"text\"],\n    defaultOutputModes=[\"text\"],\n    capabilities=capabilities,\n    skills=[skill]\n  )\n  logging.info(agent_card)\n\nif __name__ == \"__main__\":\n  main()\n</code></pre>"},{"location":"tutorials/python/5-add-agent-card/#test-run","title":"Test Run","text":"<p>Let's give this a run.</p> <pre><code>uv run my-project\n</code></pre> <p>The output should look something like this.</p> <pre><code>INFO:root:name='Echo Agent' description='This agent echos the input given' url='http://localhost:10002/' provider=None version='0.1.0' documentationUrl=None capabilities=AgentCapabilities(streaming=False, pushNotifications=False, stateTransitionHistory=False) authentication=None defaultInputModes=['text'] defaultOutputModes=['text'] skills=[AgentSkill(id='my-project-echo-skill', name='Echo Tool', description='Echos the input given', tags=['echo', 'repeater'], examples=['I will see this echoed back to me'], inputModes=['text'], outputModes=['text'])]\n</code></pre> <p>Prev Next</p>"},{"location":"tutorials/python/6-start-server/","title":"A2A Server","text":"<p>We're almost ready to start our server! We'll be using the <code>A2AServer</code> class from <code>Google-A2A</code> which under the hood starts a uvicorn server. However in the future this may change as <code>Google-A2A</code> is still in development.</p>"},{"location":"tutorials/python/6-start-server/#task-manager","title":"Task Manager","text":"<p>Before we create our server, we need a task manager to handle incoming requests.</p> <p>We'll be implementing the InMemoryTaskManager interface which requires us to implement two methods</p> <pre><code>async def on_send_task(\n  self,\n  request: SendTaskRequest\n) -&gt; SendTaskResponse:\n  \"\"\"\n  This method queries or creates a task for the agent.\n  The caller will receive exactly one response.\n  \"\"\"\n  pass\n\nasync def on_send_task_subscribe(\n  self,\n  request: SendTaskStreamingRequest\n) -&gt; AsyncIterable[SendTaskStreamingResponse] | JSONRPCResponse:\n  \"\"\"\n  This method subscribes the caller to future updates regarding a task.\n  The caller will receive a response and additionally receive subscription\n  updates over a session established between the client and the server\n  \"\"\"\n  pass\n</code></pre> <p>Open up <code>src/my_project/task_manager.py</code> and add the following code. We will simply returns a direct echo response and immediately mark the task complete without any sessions or subscriptions</p> <pre><code>from typing import AsyncIterable\n\nimport google_a2a\nfrom google_a2a.common.server.task_manager import InMemoryTaskManager\nfrom google_a2a.common.types import (\n  Artifact,\n  JSONRPCResponse,\n  Message,\n  SendTaskRequest,\n  SendTaskResponse,\n  SendTaskStreamingRequest,\n  SendTaskStreamingResponse,\n  Task,\n  TaskState,\n  TaskStatus,\n  TaskStatusUpdateEvent,\n)\n\nclass MyAgentTaskManager(InMemoryTaskManager):\n  def __init__(self):\n    super().__init__()\n\n  async def on_send_task(self, request: SendTaskRequest) -&gt; SendTaskResponse:\n    # Upsert a task stored by InMemoryTaskManager\n    await self.upsert_task(request.params)\n\n    task_id = request.params.id\n    # Our custom logic that simply marks the task as complete\n    # and returns the echo text\n    received_text = request.params.message.parts[0].text\n    task = await self._update_task(\n      task_id=task_id,\n      task_state=TaskState.COMPLETED,\n      response_text=f\"on_send_task received: {received_text}\"\n    )\n\n    # Send the response\n    return SendTaskResponse(id=request.id, result=task)\n\n  async def on_send_task_subscribe(\n    self,\n    request: SendTaskStreamingRequest\n  ) -&gt; AsyncIterable[SendTaskStreamingResponse] | JSONRPCResponse:\n    pass\n\n  async def _update_task(\n    self,\n    task_id: str,\n    task_state: TaskState,\n    response_text: str,\n  ) -&gt; Task:\n    task = self.tasks[task_id]\n    agent_response_parts = [\n      {\n        \"type\": \"text\",\n        \"text\": response_text,\n      }\n    ]\n    task.status = TaskStatus(\n      state=task_state,\n      message=Message(\n        role=\"agent\",\n        parts=agent_response_parts,\n      )\n    )\n    task.artifacts = [\n      Artifact(\n        parts=agent_response_parts,\n      )\n    ]\n    return task\n</code></pre>"},{"location":"tutorials/python/6-start-server/#a2a-server_1","title":"A2A Server","text":"<p>With a task manager complete, we can now create our server</p> <p>Open up <code>src/my_project/__init__.py</code> and add the following code.</p> <pre><code># ...\nfrom google_a2a.common.server import A2AServer\nfrom my_project.task_manager import MyAgentTaskManager\n# ...\ndef main(host, port):\n  # ...\n\n  task_manager = MyAgentTaskManager()\n  server = A2AServer(\n    agent_card=agent_card,\n    task_manager=task_manager,\n    host=host,\n    port=port,\n  )\n  server.start()\n</code></pre>"},{"location":"tutorials/python/6-start-server/#test-run","title":"Test Run","text":"<p>Let's give this a run.</p> <pre><code>uv run my-project\n</code></pre> <p>The output should look something like this.</p> <pre><code>INFO:     Started server process [20506]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://localhost:10002 (Press CTRL+C to quit)\n</code></pre> <p>Congratulations! Your A2A server is now running!</p> <p>Prev Next</p>"},{"location":"tutorials/python/7-interact-with-server/","title":"Interacting With Your A2A Server","text":"<p>First we'll use Google-A2A's command-line tool to send requests to our A2A server. After trying it out, we'll write our own basic client to see how this works under the hood</p>"},{"location":"tutorials/python/7-interact-with-server/#using-google-a2as-command-line-tool","title":"Using Google-A2A's command-line tool","text":"<p>With your A2A server already running from the previous run</p> <pre><code># This should already be running in your terminal\n$ uv run my-project\nINFO:     Started server process [20538]\nINFO:     Waiting for application startup.\nINFO:     Application startup complete.\nINFO:     Uvicorn running on http://localhost:10002 (Press CTRL+C to quit)\n</code></pre> <p>Open up a new terminal in the same directory</p> <pre><code>source .venv/bin/activate\nuv run google-a2a-cli --agent http://localhost:10002\n</code></pre> <p>Note: This will only work if you've installed google-a2a from this pull request as the cli was not exposed previously.</p> <p>Otherwise you'll have to checkout the Google/A2A repository directly, navigate to the <code>samples/python</code> repository and run the cli directly</p> <p>You can then send messages to your server and pressing Enter</p> <pre><code>=========  starting a new task ========\n\nWhat do you want to send to the agent? (:q or quit to exit): Hello!\n</code></pre> <p>If everything is working correctly you'll see this in the response</p> <pre><code>\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"on_send_task received: Hello!\"}]}\n</code></pre> <p>To exit type <code>:q</code> and press Enter</p> <p>Prev Next</p>"},{"location":"tutorials/python/8-agent-capabilities/","title":"Adding Agent Capabilities","text":"<p>Now that we have a basic A2A server running, let's add some more functionality. We'll explore how A2A can work asynchronously and stream responses.</p>"},{"location":"tutorials/python/8-agent-capabilities/#streaming","title":"Streaming","text":"<p>This allows clients to subscribe to the server and receive multiple updates instead of a single response. This can be useful for long running agent tasks, or where multiple Artifacts may streamed back to the client. See the Streaming Documentation</p> <p>First we'll declare our agent as ready for streaming. Open up <code>src/my_project/__init__.py</code> and update AgentCapabilities</p> <pre><code># ...\ndef main(host, port):\n  # ...\n  capabilities = AgentCapabilities(\n    streaming=True\n  )\n  # ...\n</code></pre> <p>Now in <code>src/my_project/task_manager.py</code> we'll have to implement <code>on_send_task_subscribe</code></p> <pre><code>import asyncio\n# ...\nclass MyAgentTaskManager(InMemoryTaskManager):\n  # ...\n  async def _stream_3_messages(self, request: SendTaskStreamingRequest):\n    task_id = request.params.id\n    received_text = request.params.message.parts[0].text\n\n    text_messages = [\"one\", \"two\", \"three\"]\n    for text in text_messages:\n      parts = [\n        {\n          \"type\": \"text\",\n          \"text\": f\"{received_text}: {text}\",\n        }\n      ]\n      message = Message(role=\"agent\", parts=parts)\n      is_last = text == text_messages[-1]\n      task_state = TaskState.COMPLETED if is_last else TaskState.WORKING\n      task_status = TaskStatus(\n        state=task_state,\n        message=message\n      )\n      task_update_event = TaskStatusUpdateEvent(\n        id=request.params.id,\n        status=task_status,\n        final=is_last,\n      )\n      await self.enqueue_events_for_sse(\n        request.params.id,\n        task_update_event\n      )\n\n  async def on_send_task_subscribe(\n    self,\n    request: SendTaskStreamingRequest\n  ) -&gt; AsyncIterable[SendTaskStreamingResponse] | JSONRPCResponse:\n    # Upsert a task stored by InMemoryTaskManager\n    await self.upsert_task(request.params)\n\n    task_id = request.params.id\n    # Create a queue of work to be done for this task\n    sse_event_queue = await self.setup_sse_consumer(task_id=task_id)\n\n    # Start the asynchronous work for this task\n    asyncio.create_task(self._stream_3_messages(request))\n\n    # Tell the client to expect future streaming responses\n    return self.dequeue_events_for_sse(\n      request_id=request.id,\n      task_id=task_id,\n      sse_event_queue=sse_event_queue,\n    )\n</code></pre> <p>Restart your A2A server to pickup the new changes and then rerun the cli</p> <pre><code>$ uv run google-a2a-cli --agent http://localhost:10002\n=========  starting a new task ========\n\nWhat do you want to send to the agent? (:q or quit to exit): Streaming?\n\n\"status\":{\"state\":\"working\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Streaming?: one\"}]}\n\"status\":{\"state\":\"working\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Streaming?: two\"}]}\n\"status\":{\"state\":\"completed\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Streaming?: three\"}]}\n</code></pre> <p>Sometimes the agent might need additional input. For example, maybe the agent will ask the client if they'd like to keep repeating the 3 messages. In this case, the agent will respond with <code>TaskState.INPUT_REQUIRED</code> to which the client will then resend <code>send_task_streaming</code> with the same <code>task_id</code> and <code>session_id</code> but with an updated message providing the input required by the agent. On the server-side we'll update <code>on_send_task_subscribe</code> to handle this case.</p> <pre><code># ...\n\nclass MyAgentTaskManager(InMemoryTaskManager):\n  # ...\n  async def _stream_3_messages(self, request: SendTaskStreamingRequest):\n    # ...\n    async for message in messages:\n      # ...\n      # is_last = message == messages[-1] # Delete this line\n      task_state = TaskState.WORKING\n      # ...\n      task_update_event = TaskStatusUpdateEvent(\n        id=request.params.id,\n        status=task_status,\n        final=False,\n      )\n      # ...\n\n    ask_message = Message(\n      role=\"agent\",\n      parts=[\n        {\n          \"type\": \"text\",\n          \"text\": \"Would you like more messages? (Y/N)\"\n        }\n      ]\n    )\n    task_update_event = TaskStatusUpdateEvent(\n      id=request.params.id,\n      status=TaskStatus(\n        state=TaskState.INPUT_REQUIRED,\n        message=ask_message\n      ),\n      final=True,\n    )\n    await self.enqueue_events_for_sse(\n      request.params.id,\n      task_update_event\n    )\n  # ...\n  async def on_send_task_subscribe(\n    self,\n    request: SendTaskStreamingRequest\n  ) -&gt; AsyncIterable[SendTaskStreamingResponse] | JSONRPCResponse:\n    task_id = request.params.id\n    is_new_task = task_id in self.tasks\n    # Upsert a task stored by InMemoryTaskManager\n    await self.upsert_task(request.params)\n\n    received_text = request.params.message.parts[0].text\n    sse_event_queue = await self.setup_sse_consumer(task_id=task_id)\n    if not is_new_task and received_text == \"N\":\n      task_update_event = TaskStatusUpdateEvent(\n        id=request.params.id,\n        status=TaskStatus(\n          state=TaskState.COMPLETED,\n          message=Message(\n            role=\"agent\",\n            parts=[\n              {\n                \"type\": \"text\",\n                \"text\": \"All done!\"\n              }\n            ]\n          )\n        ),\n        final=True,\n      )\n      await self.enqueue_events_for_sse(\n        request.params.id,\n        task_update_event,\n      )\n    else:\n      asyncio.create_task(self._stream_3_messages(request))\n\n    return self.dequeue_events_for_sse(\n      request_id=request.id,\n      task_id=task_id,\n      sse_event_queue=sse_event_queue,\n    )\n</code></pre> <p>Now after restarting the server and running the cli, we can see the task will keep running until we tell the agent <code>N</code></p> <pre><code>$ uv run google-a2a-cli --agent http://localhost:10002\n=========  starting a new task ========\n\nWhat do you want to send to the agent? (:q or quit to exit): Streaming?\n\n\"status\":{\"state\":\"working\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Streaming?: one\"}]}\n\"status\":{\"state\":\"working\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Streaming?: two\"}]}\n\"status\":{\"state\":\"working\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Streaming?: three\"}]}\n\"status\":{\"state\":\"input-required\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"Would you like more messages? (Y/N)\"}]}\n\nWhat do you want to send to the agent? (:q or quit to exit): N\n\n\"status\":{\"state\":\"completed\",\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"All done!\"}]}\n</code></pre> <p>Congradulations! You now have an agent that is able to asynchronously perform work and ask users for input when needed.</p>"},{"location":"tutorials/python/8-agent-capabilities/#other-capabilities","title":"Other Capabilities","text":"<p>If you're interested, check out the documentation for other capabilities for your A2A agent. For now we'll jump into adding AI into A2A using a local LLM.</p> <p>Prev Next</p>"},{"location":"tutorials/python/9-ollama-agent/","title":"Using a Local Ollama Model","text":"<p>Now we get to the exciting part. We're going to add AI to our A2A server.</p> <p>In this tutorial, we'll be setting up a local Ollama model and integrating it with our A2A server. However there are many other options such as using Google's Agent Development Kit (ADK). You can check out the sample projects on GitHub.</p>"},{"location":"tutorials/python/9-ollama-agent/#requirements","title":"Requirements","text":"<p>We'll be installing <code>ollama</code>, <code>langchain</code> as well as downloading an ollama model that supports MCP tools (for a future tutorial).</p> <ol> <li>Download ollama</li> <li>Run an ollama server</li> </ol> <pre><code># Note: if ollama is already running, you may get an error such as\n# Error: listen tcp 127.0.0.1:11434: bind: address already in use\n# On linux you can run systemctl stop ollama to stop ollama\nollama serve\n</code></pre> <ol> <li>Download a model from this list. We'll be using <code>qwq</code> as it supports <code>tools</code> (as shown by its tags) and runs on a 24GB graphics card</li> </ol> <pre><code>ollama pull qwq\n</code></pre> <ol> <li>Install <code>langchain</code></li> </ol> <pre><code>uv add langchain langchain-ollama langgraph\n</code></pre> <p>Now with ollama setup, we can start integrating it into our A2A server</p>"},{"location":"tutorials/python/9-ollama-agent/#integrating-ollama-into-our-a2a-server","title":"Integrating Ollama into our A2A server","text":"<p>First open up <code>src/my_project/__init__.py</code></p> <pre><code># ...\n\n@click.command()\n@click.option(\"--host\", default=\"localhost\")\n@click.option(\"--port\", default=10002)\n@click.option(\"--ollama-host\", default=\"http://127.0.0.1:11434\")\n@click.option(\"--ollama-model\", default=None)\ndef main(host, port, ollama_host, ollama_model):\n  # ...\n  capabilities = AgentCapabilities(\n    streaming=False # We'll leave streaming capabilities as an exercise for the reader\n  )\n  # ...\n  task_manager = MyAgentTaskManager(\n    ollama_host=ollama_host,\n    ollama_model=ollama_model,\n  )\n  # ..\n</code></pre> <p>Now let's add AI functionality in <code>src/my_project/agent.py</code></p> <pre><code>from langchain_ollama import ChatOllama\nfrom langgraph.prebuilt import create_react_agent\nfrom langgraph.graph.graph import CompiledGraph\n\ndef create_ollama_agent(ollama_base_url: str, ollama_model: str):\n  ollama_chat_llm = ChatOllama(\n    base_url=ollama_base_url,\n    model=ollama_model,\n    temperature=0.2\n  )\n  agent = create_react_agent(ollama_chat_llm, tools=[])\n  return agent\n\nasync def run_ollama(ollama_agent: CompiledGraph, prompt: str):\n  agent_response = await ollama_agent.ainvoke(\n    {\"messages\": prompt }\n  )\n  message = agent_response[\"messages\"][-1].content\n  return str(message)\n</code></pre> <p>Finally let's call our ollama agent from <code>src/my_project/task_manager.py</code></p> <pre><code># ...\nfrom my_project.agent import create_ollama_agent, run_ollama\n\nclass MyAgentTaskManager(InMemoryTaskManager):\n  def __init__(\n    self,\n    ollama_host: str,\n    ollama_model: typing.Union[None, str]\n  ):\n    super().__init__()\n    if ollama_model is not None:\n      self.ollama_agent = create_ollama_agent(\n        ollama_base_url=ollama_host,\n        ollama_model=ollama_model\n      )\n    else:\n      self.ollama_agent = None\n\n  async def on_send_task(self, request: SendTaskRequest) -&gt; SendTaskResponse:\n    # ...\n    received_text = request.params.message.parts[0].text\n    response_text = f\"on_send_task received: {received_text}\"\n    if self.ollama_agent is not None:\n      response_text = await run_ollama(ollama_agent=self.ollama_agent, prompt=received_text)\n\n    task = await self._update_task(\n      task_id=task_id,\n      task_state=TaskState.COMPLETED,\n      response_text=response_text\n    )\n\n    # Send the response\n    return SendTaskResponse(id=request.id, result=task)\n\n  # ...\n</code></pre> <p>Lets test it out!</p> <p>First rerun our A2A server replacing <code>qwq</code> with the ollama model you downloaded</p> <pre><code>uv run my-project --ollama-host http://127.0.0.1:11434 --ollama-model qwq\n</code></pre> <p>And then rerun the cli</p> <pre><code>uv run google-a2a-cli --agent http://localhost:10002\n</code></pre> <p>Note, if you're using a large model, it may take a while to load. The cli may timeout. In which case rerun the cli once the ollama server has finished loading the model.</p> <p>You should see something like the following</p> <pre><code>=========  starting a new task ========\n\nWhat do you want to send to the agent? (:q or quit to exit): hey\n\n\"message\":{\"role\":\"agent\",\"parts\":[{\"type\":\"text\",\"text\":\"&lt;think&gt;\\nOkay, the user said \\\"hey\\\". That's pretty casual. I should respond in a friendly way. Maybe ask how I can help them today. Keep it open-ended so they feel comfortable sharing what they need. Let me make sure my tone is positive and approachable. Alright, something like, \\\"Hey there! How can I assist you today?\\\" Yeah, that sounds good.\\n&lt;/think&gt;\\n\\nHey there! How can I assist you today? \ud83d\ude0a\"}]}\n</code></pre> <p>Congratulations! You now have an A2A server generating responses using an AI model!</p> <p>Prev Next</p>"}]}